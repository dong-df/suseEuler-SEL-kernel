From 4903e798ce85d4bf0df59f59ff4482bbe6830198 Mon Sep 17 00:00:00 2001
From: Yanling Song <songyl@ramaxel.com>
Date: Mon, 17 Jan 2022 21:07:56 +0800
Subject: [PATCH] net/spnic:Remove the code about little endian and big endian
 conversion
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 4903e798ce85d4bf0df59f59ff4482bbe6830198


Ramaxel inclusion
category: bugfix
bugzilla: https://gitee.com/openeuler/kernel/issues/I4P01N
CVE: NA

Remove the code of endian converting
since hardware converts endian automatically.

Signed-off-by: Yanling Song <songyl@ramaxel.com>
Reviewed-by: Yang Gan <yanggan@ramaxel.com>
Acked-by: Xie XiuQi <xiexiuqi@huawei.com>
Acked-by: Xie XiuQi <xiexiuqi@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 .../net/ethernet/ramaxel/spnic/hw/sphw_cmdq.c | 38 +++++-------------
 .../ethernet/ramaxel/spnic/hw/sphw_common.h   | 12 ------
 .../net/ethernet/ramaxel/spnic/spnic_nic_io.h |  6 +--
 .../net/ethernet/ramaxel/spnic/spnic_nic_qp.h |  7 +---
 drivers/net/ethernet/ramaxel/spnic/spnic_rx.c | 39 +++++++------------
 drivers/net/ethernet/ramaxel/spnic/spnic_tx.c | 20 +++++-----
 6 files changed, 34 insertions(+), 88 deletions(-)

diff --git a/drivers/net/ethernet/ramaxel/spnic/hw/sphw_cmdq.c b/drivers/net/ethernet/ramaxel/spnic/hw/sphw_cmdq.c
index b6aaadac19b9..5421b813d484 100644
--- a/drivers/net/ethernet/ramaxel/spnic/hw/sphw_cmdq.c
+++ b/drivers/net/ethernet/ramaxel/spnic/hw/sphw_cmdq.c
@@ -343,10 +343,6 @@ static void cmdq_set_db(struct sphw_cmdq *cmdq,
 
 	cmdq_fill_db(&db, cmdq_type, prod_idx);
 
-	/* The data that is written to HW should be in Big Endian Format */
-	db.db_info = sphw_hw_be32(db.db_info);
-	db.db_head = sphw_hw_be32(db.db_head);
-
 	wmb();	/* write all before the doorbell */
 	writeq(*((u64 *)&db), CMDQ_DB_ADDR(cmdq->db_base, prod_idx));
 }
@@ -482,24 +478,21 @@ static void cmdq_update_cmd_status(struct sphw_cmdq *cmdq, u16 prod_idx,
 	cmd_info = &cmdq->cmd_infos[prod_idx];
 
 	if (cmd_info->errcode) {
-		status_info = sphw_hw_cpu32(wqe_lcmd->status.status_info);
+		status_info = wqe_lcmd->status.status_info;
 		*cmd_info->errcode = WQE_ERRCODE_GET(status_info, VAL);
 	}
 
 	if (cmd_info->direct_resp)
-		*cmd_info->direct_resp =
-			sphw_hw_cpu32(wqe_lcmd->completion.direct_resp);
+		*cmd_info->direct_resp = wqe_lcmd->completion.direct_resp;
 }
 
 static int sphw_cmdq_sync_timeout_check(struct sphw_cmdq *cmdq, struct sphw_cmdq_wqe *wqe, u16 pi)
 {
 	struct sphw_cmdq_wqe_lcmd *wqe_lcmd;
-	struct sphw_ctrl *ctrl;
 	u32 ctrl_info;
 
 	wqe_lcmd = &wqe->wqe_lcmd;
-	ctrl = &wqe_lcmd->ctrl;
-	ctrl_info = sphw_hw_cpu32((ctrl)->ctrl_info);
+	ctrl_info = wqe_lcmd->ctrl.ctrl_info;
 	if (!WQE_COMPLETED(ctrl_info)) {
 		sdk_info(cmdq->hwdev->dev_hdl, "Cmdq sync command check busy bit not set\n");
 		return -EFAULT;
@@ -640,7 +633,7 @@ static int cmdq_sync_cmd_direct_resp(struct sphw_cmdq *cmdq, u8 mod,
 	struct sphw_cmdq_cmd_info *cmd_info = NULL, saved_cmd_info;
 	struct completion done;
 	u16 curr_prod_idx, next_prod_idx;
-	int wrapped, errcode = 0, wqe_size = WQE_LCMD_SIZE;
+	int wrapped, errcode = 0;
 	int cmpt_code = CMDQ_SEND_CMPT_CODE;
 	u64 curr_msg_id;
 	int err;
@@ -682,9 +675,6 @@ static int cmdq_sync_cmd_direct_resp(struct sphw_cmdq *cmdq, u8 mod,
 	cmdq_set_lcmd_wqe(&wqe, SYNC_CMD_DIRECT_RESP, buf_in, NULL,
 			  wrapped, mod, cmd, curr_prod_idx);
 
-	/* The data that is written to HW should be in Big Endian Format */
-	sphw_hw_be32_len(&wqe, wqe_size);
-
 	/* CMDQ WQE is not shadow, therefore wqe will be written to wq */
 	cmdq_wqe_fill(curr_wqe, &wqe);
 
@@ -726,7 +716,7 @@ static int cmdq_sync_cmd_detail_resp(struct sphw_cmdq *cmdq, u8 mod, u8 cmd,
 	struct sphw_cmdq_cmd_info *cmd_info = NULL, saved_cmd_info;
 	struct completion done;
 	u16 curr_prod_idx, next_prod_idx;
-	int wrapped, errcode = 0, wqe_size = WQE_LCMD_SIZE;
+	int wrapped, errcode = 0;
 	int cmpt_code = CMDQ_SEND_CMPT_CODE;
 	u64 curr_msg_id;
 	int err;
@@ -768,8 +758,6 @@ static int cmdq_sync_cmd_detail_resp(struct sphw_cmdq *cmdq, u8 mod, u8 cmd,
 	cmdq_set_lcmd_wqe(&wqe, SYNC_CMD_SGE_RESP, buf_in, buf_out,
 			  wrapped, mod, cmd, curr_prod_idx);
 
-	sphw_hw_be32_len(&wqe, wqe_size);
-
 	cmdq_wqe_fill(curr_wqe, &wqe);
 
 	(cmd_info->cmdq_msg_id)++;
@@ -805,7 +793,6 @@ static int cmdq_async_cmd(struct sphw_cmdq *cmdq, u8 mod, u8 cmd,
 {
 	struct sphw_cmdq_cmd_info *cmd_info = NULL;
 	struct sphw_wq *wq = &cmdq->wq;
-	int wqe_size = WQE_LCMD_SIZE;
 	u16 curr_prod_idx, next_prod_idx;
 	struct sphw_cmdq_wqe *curr_wqe = NULL, wqe;
 	int wrapped, err;
@@ -832,8 +819,6 @@ static int cmdq_async_cmd(struct sphw_cmdq *cmdq, u8 mod, u8 cmd,
 	cmdq_set_lcmd_wqe(&wqe, ASYNC_CMD, buf_in, NULL, wrapped,
 			  mod, cmd, curr_prod_idx);
 
-	/* The data that is written to HW should be in Big Endian Format */
-	sphw_hw_be32_len(&wqe, wqe_size);
 	cmdq_wqe_fill(curr_wqe, &wqe);
 
 	cmd_info = &cmdq->cmd_infos[curr_prod_idx];
@@ -858,7 +843,7 @@ int cmdq_set_arm_bit(struct sphw_cmdq *cmdq, const void *buf_in,
 	struct sphw_wq *wq = &cmdq->wq;
 	struct sphw_cmdq_wqe *curr_wqe = NULL, wqe;
 	u16 curr_prod_idx, next_prod_idx;
-	int wrapped, wqe_size = WQE_SCMD_SIZE;
+	int wrapped;
 
 	/* Keep wrapped and doorbell index correct. bh - for tasklet(ceq) */
 	spin_lock_bh(&cmdq->cmdq_lock);
@@ -883,9 +868,6 @@ int cmdq_set_arm_bit(struct sphw_cmdq *cmdq, const void *buf_in,
 			    wrapped, SPHW_MOD_COMM, CMDQ_SET_ARM_CMD,
 			    curr_prod_idx);
 
-	/* The data that is written to HW should be in Big Endian Format */
-	sphw_cpu_to_be32(&wqe, wqe_size);
-
 	/* cmdq wqe is not shadow, therefore wqe will be written to wq */
 	cmdq_wqe_fill(curr_wqe, &wqe);
 
@@ -1102,7 +1084,7 @@ static void clear_wqe_complete_bit(struct sphw_cmdq *cmdq,
 				   struct sphw_cmdq_wqe *wqe, u16 ci)
 {
 	struct sphw_ctrl *ctrl = NULL;
-	u32 header_info = sphw_hw_cpu32(WQE_HEADER(wqe)->header_info);
+	u32 header_info = WQE_HEADER(wqe)->header_info;
 	enum data_format df = CMDQ_WQE_HEADER_GET(header_info, DATA_FMT);
 
 	if (df == DATA_SGE)
@@ -1157,7 +1139,7 @@ static int cmdq_arm_ceq_handler(struct sphw_cmdq *cmdq,
 				struct sphw_cmdq_wqe *wqe, u16 ci)
 {
 	struct sphw_ctrl *ctrl = &wqe->inline_wqe.wqe_scmd.ctrl;
-	u32 ctrl_info = sphw_hw_cpu32((ctrl)->ctrl_info);
+	u32 ctrl_info = ctrl->ctrl_info;
 
 	if (!WQE_COMPLETED(ctrl_info))
 		return -EBUSY;
@@ -1188,7 +1170,6 @@ void sphw_cmdq_ceq_handler(void *handle, u32 ceqe_data)
 	struct sphw_hwdev *hwdev = cmdqs->hwdev;
 	struct sphw_cmdq_wqe *wqe = NULL;
 	struct sphw_cmdq_wqe_lcmd *wqe_lcmd = NULL;
-	struct sphw_ctrl *ctrl = NULL;
 	struct sphw_cmdq_cmd_info *cmd_info = NULL;
 	u32 ctrl_info;
 	u16 ci;
@@ -1216,8 +1197,7 @@ void sphw_cmdq_ceq_handler(void *handle, u32 ceqe_data)
 		default:
 			/* only arm bit is using scmd wqe, the wqe is lcmd */
 			wqe_lcmd = &wqe->wqe_lcmd;
-			ctrl = &wqe_lcmd->ctrl;
-			ctrl_info = sphw_hw_cpu32((ctrl)->ctrl_info);
+			ctrl_info = wqe_lcmd->ctrl.ctrl_info;
 
 			if (!WQE_COMPLETED(ctrl_info))
 				return;
diff --git a/drivers/net/ethernet/ramaxel/spnic/hw/sphw_common.h b/drivers/net/ethernet/ramaxel/spnic/hw/sphw_common.h
index d6e2f183cc36..05327bd4bcfe 100644
--- a/drivers/net/ethernet/ramaxel/spnic/hw/sphw_common.h
+++ b/drivers/net/ethernet/ramaxel/spnic/hw/sphw_common.h
@@ -93,18 +93,6 @@ static inline void sphw_set_sge(struct sphw_sge *sge, dma_addr_t addr, int len)
 	sge->len = len;
 }
 
-#define sphw_hw_be32(val) (val)
-#define sphw_hw_cpu32(val) (val)
-#define sphw_hw_cpu16(val) (val)
-
-static inline void sphw_hw_be32_len(void *data, int len)
-{
-}
-
-static inline void sphw_hw_cpu32_len(void *data, int len)
-{
-}
-
 #define sdk_err(dev, format, ...) dev_err(dev, "[COMM]" format, ##__VA_ARGS__)
 #define sdk_warn(dev, format, ...) dev_warn(dev, "[COMM]" format, ##__VA_ARGS__)
 #define sdk_notice(dev, format, ...) dev_notice(dev, "[COMM]" format, ##__VA_ARGS__)
diff --git a/drivers/net/ethernet/ramaxel/spnic/spnic_nic_io.h b/drivers/net/ethernet/ramaxel/spnic/spnic_nic_io.h
index ab1399d3e36c..e237ba33d82d 100644
--- a/drivers/net/ethernet/ramaxel/spnic/spnic_nic_io.h
+++ b/drivers/net/ethernet/ramaxel/spnic/spnic_nic_io.h
@@ -101,8 +101,7 @@ static inline u16 spnic_get_sq_local_pi(struct spnic_io_queue *sq)
  */
 static inline u16 spnic_get_sq_hw_ci(struct spnic_io_queue *sq)
 {
-	return WQ_MASK_IDX(&sq->wq,
-			   sphw_hw_cpu16(*(u16 *)sq->tx.cons_idx_addr));
+	return WQ_MASK_IDX(&sq->wq, *(u16 *)sq->tx.cons_idx_addr);
 }
 
 /* *
@@ -281,9 +280,6 @@ static inline void spnic_write_db(struct spnic_io_queue *queue, int cos, u8 cfla
 	db.db_info = DB_INFO_SET(SRC_TYPE, TYPE) | DB_INFO_SET(cflag, CFLAG) |
 			DB_INFO_SET(cos, COS) | DB_INFO_SET(queue->q_id, QID);
 	db.pi_hi = DB_PI_HIGH(pi);
-	/* Data should be written to HW in Big Endian Format */
-	db.db_info = sphw_hw_be32(db.db_info);
-	db.pi_hi = sphw_hw_be32(db.pi_hi);
 
 	wmb(); /* Write all before the doorbell */
 
diff --git a/drivers/net/ethernet/ramaxel/spnic/spnic_nic_qp.h b/drivers/net/ethernet/ramaxel/spnic/spnic_nic_qp.h
index 4c3f37e45a36..a8abdc1734d3 100644
--- a/drivers/net/ethernet/ramaxel/spnic/spnic_nic_qp.h
+++ b/drivers/net/ethernet/ramaxel/spnic/spnic_nic_qp.h
@@ -352,7 +352,7 @@ enum sq_wqe_tasksect_len_type {
 
 static inline u32 spnic_get_pkt_len_for_super_cqe(struct spnic_rq_cqe *cqe, bool last)
 {
-	u32 pkt_len = sphw_hw_cpu32(cqe->pkt_info);
+	u32 pkt_len = cqe->pkt_info;
 
 	if (!last)
 		return RQ_CQE_PKT_LEN_GET(pkt_len, FIRST_LEN);
@@ -376,7 +376,6 @@ static inline void spnic_prepare_sq_ctrl(struct spnic_sq_wqe_combo *wqe_combo,
 		    SQ_CTRL_SET(wqe_combo->wqe_type, EXTENDED) |
 		    SQ_CTRL_SET(owner, OWNER);
 
-		wqe_desc->ctrl_len = sphw_hw_be32(wqe_desc->ctrl_len);
 		/* compact wqe queue_info will transfer to ucode */
 		wqe_desc->queue_info = 0;
 		return;
@@ -388,8 +387,6 @@ static inline void spnic_prepare_sq_ctrl(struct spnic_sq_wqe_combo *wqe_combo,
 			      SQ_CTRL_SET(wqe_combo->wqe_type, EXTENDED) |
 			      SQ_CTRL_SET(owner, OWNER);
 
-	wqe_desc->ctrl_len = sphw_hw_be32(wqe_desc->ctrl_len);
-
 	wqe_desc->queue_info = queue_info;
 	wqe_desc->queue_info |= SQ_CTRL_QUEUE_INFO_SET(1U, UC);
 
@@ -400,8 +397,6 @@ static inline void spnic_prepare_sq_ctrl(struct spnic_sq_wqe_combo *wqe_combo,
 		wqe_desc->queue_info = SQ_CTRL_QUEUE_INFO_CLEAR(wqe_desc->queue_info, MSS);
 		wqe_desc->queue_info |= SQ_CTRL_QUEUE_INFO_SET(TX_MSS_MIN, MSS);
 	}
-
-	wqe_desc->queue_info = sphw_hw_be32(wqe_desc->queue_info);
 }
 
 /* *
diff --git a/drivers/net/ethernet/ramaxel/spnic/spnic_rx.c b/drivers/net/ethernet/ramaxel/spnic/spnic_rx.c
index e58da6771ff4..3ae2f15c727b 100644
--- a/drivers/net/ethernet/ramaxel/spnic/spnic_rx.c
+++ b/drivers/net/ethernet/ramaxel/spnic/spnic_rx.c
@@ -92,7 +92,6 @@ static u32 spnic_rx_fill_wqe(struct spnic_rxq *rxq)
 {
 	struct net_device *netdev = rxq->netdev;
 	struct spnic_nic_dev *nic_dev = netdev_priv(netdev);
-	int rq_wqe_len = rxq->rq->wq.wqebb_size;
 	struct spnic_rq_wqe *rq_wqe = NULL;
 	struct spnic_rx_info *rx_info = NULL;
 	u32 i;
@@ -113,7 +112,6 @@ static u32 spnic_rx_fill_wqe(struct spnic_rxq *rxq)
 			rq_wqe->normal_wqe.cqe_lo_addr = lower_32_bits(rx_info->cqe_dma);
 		}
 
-		sphw_hw_be32_len(rq_wqe, rq_wqe_len);
 		rx_info->rq_wqe = rq_wqe;
 	}
 
@@ -179,17 +177,12 @@ static u32 stub_spnic_rx_fill_buffers(struct spnic_rxq *rxq)
 		dma_addr = rx_info->buf_dma_addr;
 
 		if (rxq->rq->wqe_type == SPNIC_EXTEND_RQ_WQE) {
-			rq_wqe->extend_wqe.buf_desc.sge.hi_addr =
-				sphw_hw_be32(upper_32_bits(dma_addr));
-			rq_wqe->extend_wqe.buf_desc.sge.lo_addr =
-				sphw_hw_be32(lower_32_bits(dma_addr));
-			rq_wqe->extend_wqe.buf_desc.sge.len =
-				sphw_hw_be32(rx_info->skb_len);
+			rq_wqe->extend_wqe.buf_desc.sge.hi_addr = upper_32_bits(dma_addr);
+			rq_wqe->extend_wqe.buf_desc.sge.lo_addr = lower_32_bits(dma_addr);
+			rq_wqe->extend_wqe.buf_desc.sge.len = rx_info->skb_len;
 		} else {
-			rq_wqe->normal_wqe.buf_hi_addr =
-				sphw_hw_be32(upper_32_bits(dma_addr));
-			rq_wqe->normal_wqe.buf_lo_addr =
-				sphw_hw_be32(lower_32_bits(dma_addr));
+			rq_wqe->normal_wqe.buf_hi_addr = upper_32_bits(dma_addr);
+			rq_wqe->normal_wqe.buf_lo_addr = lower_32_bits(dma_addr);
 		}
 		rxq->next_to_update = (rxq->next_to_update + 1) & rxq->q_mask;
 	}
@@ -236,15 +229,11 @@ static u32 spnic_rx_fill_buffers(struct spnic_rxq *rxq)
 		rq_wqe = rx_info->rq_wqe;
 
 		if (rxq->rq->wqe_type == SPNIC_EXTEND_RQ_WQE) {
-			rq_wqe->extend_wqe.buf_desc.sge.hi_addr =
-				sphw_hw_be32(upper_32_bits(dma_addr));
-			rq_wqe->extend_wqe.buf_desc.sge.lo_addr =
-				sphw_hw_be32(lower_32_bits(dma_addr));
+			rq_wqe->extend_wqe.buf_desc.sge.hi_addr = upper_32_bits(dma_addr);
+			rq_wqe->extend_wqe.buf_desc.sge.lo_addr = lower_32_bits(dma_addr);
 		} else {
-			rq_wqe->normal_wqe.buf_hi_addr =
-				sphw_hw_be32(upper_32_bits(dma_addr));
-			rq_wqe->normal_wqe.buf_lo_addr =
-				sphw_hw_be32(lower_32_bits(dma_addr));
+			rq_wqe->normal_wqe.buf_hi_addr = upper_32_bits(dma_addr);
+			rq_wqe->normal_wqe.buf_lo_addr = lower_32_bits(dma_addr);
 		}
 		rxq->next_to_update = (rxq->next_to_update + 1) & rxq->q_mask;
 	}
@@ -784,7 +773,7 @@ int recv_one_pkt(struct spnic_rxq *rxq, struct spnic_rq_cqe *rx_cqe,
 	if (skb_is_nonlinear(skb))
 		spnic_pull_tail(skb);
 
-	offload_type = sphw_hw_cpu32(rx_cqe->offload_type);
+	offload_type = rx_cqe->offload_type;
 	spnic_rx_csum(rxq, offload_type, status, skb);
 
 	spnic_rx_gro(rxq, offload_type, skb);
@@ -867,7 +856,7 @@ static inline int recv_supper_cqe(struct spnic_rxq *rxq, struct spnic_rq_cqe *rx
 #define LRO_PKT_HDR_LEN_IPV4		66
 #define LRO_PKT_HDR_LEN_IPV6		86
 #define LRO_PKT_HDR_LEN(cqe)		\
-	(SPNIC_GET_RX_IP_TYPE(sphw_hw_cpu32((cqe)->offload_type)) == \
+	(SPNIC_GET_RX_IP_TYPE((cqe)->offload_type) == \
 	 SPNIC_RX_IPV6_PKT ? LRO_PKT_HDR_LEN_IPV6 : LRO_PKT_HDR_LEN_IPV4)
 
 static void stub_rx_recv_jumbo_pkt(struct spnic_rxq *rxq, struct sk_buff *head_skb,
@@ -997,7 +986,7 @@ int spnic_rx_poll(struct spnic_rxq *rxq, int budget)
 	while (likely(pkts < budget)) {
 		sw_ci = rxq->cons_idx & rxq->q_mask;
 		rx_cqe = rxq->rx_info[sw_ci].cqe;
-		status = sphw_hw_cpu32(rx_cqe->status);
+		status = rx_cqe->status;
 
 		if (!SPNIC_GET_RX_DONE(status))
 			break;
@@ -1005,8 +994,8 @@ int spnic_rx_poll(struct spnic_rxq *rxq, int budget)
 		/* make sure we read rx_done before packet length */
 		rmb();
 
-		vlan_len = sphw_hw_cpu32(rx_cqe->vlan_len);
-		pkt_info = sphw_hw_cpu32(rx_cqe->pkt_info);
+		vlan_len = rx_cqe->vlan_len;
+		pkt_info = rx_cqe->pkt_info;
 		pkt_len = SPNIC_GET_RX_PKT_LEN(vlan_len);
 
 		if (unlikely(SPNIC_GET_SUPER_CQE_EN(pkt_info))) {
diff --git a/drivers/net/ethernet/ramaxel/spnic/spnic_tx.c b/drivers/net/ethernet/ramaxel/spnic/spnic_tx.c
index 57344f89a4dc..7478e76aa729 100644
--- a/drivers/net/ethernet/ramaxel/spnic/spnic_tx.c
+++ b/drivers/net/ethernet/ramaxel/spnic/spnic_tx.c
@@ -86,9 +86,9 @@ static void txq_stats_init(struct spnic_txq *txq)
 
 static inline void spnic_set_buf_desc(struct spnic_sq_bufdesc *buf_descs, dma_addr_t addr, u32 len)
 {
-	buf_descs->hi_addr = sphw_hw_be32(upper_32_bits(addr));
-	buf_descs->lo_addr = sphw_hw_be32(lower_32_bits(addr));
-	buf_descs->len  = sphw_hw_be32(len);
+	buf_descs->hi_addr = upper_32_bits(addr);
+	buf_descs->lo_addr = lower_32_bits(addr);
+	buf_descs->len = len;
 }
 
 static int tx_map_skb(struct spnic_nic_dev *nic_dev, struct sk_buff *skb,
@@ -112,8 +112,8 @@ static int tx_map_skb(struct spnic_nic_dev *nic_dev, struct sk_buff *skb,
 
 	dma_info[0].len = skb_headlen(skb);
 
-	wqe_desc->hi_addr = sphw_hw_be32(upper_32_bits(dma_info[0].dma));
-	wqe_desc->lo_addr = sphw_hw_be32(lower_32_bits(dma_info[0].dma));
+	wqe_desc->hi_addr = upper_32_bits(dma_info[0].dma);
+	wqe_desc->lo_addr = lower_32_bits(dma_info[0].dma);
 
 	wqe_desc->ctrl_len = dma_info[0].len;
 
@@ -525,12 +525,10 @@ static netdev_tx_t spnic_send_one_skb(struct sk_buff *skb, struct net_device *ne
 
 	owner = spnic_set_wqe_combo(txq, &wqe_combo, offload, num_sge, &pi);
 	if (offload) {
-		/* ip6_frag_id is big endiant, not need to transfer */
-		wqe_combo.task->ip_identify = sphw_hw_be32(task.ip_identify);
-		wqe_combo.task->pkt_info0 = sphw_hw_be32(task.pkt_info0);
-		wqe_combo.task->pkt_info2 = sphw_hw_be32(task.pkt_info2);
-		wqe_combo.task->vlan_offload =
-			sphw_hw_be32(task.vlan_offload);
+		wqe_combo.task->ip_identify = task.ip_identify;
+		wqe_combo.task->pkt_info0 = task.pkt_info0;
+		wqe_combo.task->pkt_info2 = task.pkt_info2;
+		wqe_combo.task->vlan_offload = task.vlan_offload;
 	}
 
 	tx_info = &txq->tx_info[pi];
-- 
2.26.2

