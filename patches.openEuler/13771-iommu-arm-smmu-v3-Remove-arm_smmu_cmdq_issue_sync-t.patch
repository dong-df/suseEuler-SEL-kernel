From 556e8ce5f36b86b402d802cb83467a85aaaebf2c Mon Sep 17 00:00:00 2001
From: Zhen Lei <thunder.leizhen@huawei.com>
Date: Sat, 22 Jan 2022 17:58:21 +0800
Subject: [PATCH] iommu/arm-smmu-v3: Remove arm_smmu_cmdq_issue_sync() to keep
 consistent with upstream
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 556e8ce5f36b86b402d802cb83467a85aaaebf2c
Modified-by-SEL: No


hulk inclusion
category: bugfix
bugzilla: https://e.gitee.com/open_euler/issues/list?issue=I4QSVV
CVE: NA

-------------------------------------------------------------------------

The commit 587e6c10a7ce ("iommu/arm-smmu-v3: Add and use static helper
function arm_smmu_cmdq_issue_cmd_with_sync()") is backported from RFC
version. Some minor changes are made to the patch when it is merged into
the mainline, see the following link:
Link: https://www.spinics.net/lists/arm-kernel/msg914548.html

In addition, there are two patches based on earlier mainline that still
incorrectly use arm_smmu_cmdq_issue_sync(), fix them.

Fixes: 3e63033675c9 ("iommu/arm-smmu-v3: Seize private ASID")
Fixes: 04039cc97a88 ("iommu/smmuv3: Implement cache_invalidate")
Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
Reviewed-by: Hanjun Guo <guohanjun@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c | 28 ++++++++-------------
 1 file changed, 10 insertions(+), 18 deletions(-)

diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
index 0702408997c9..f6868511ad01 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
@@ -1030,8 +1030,9 @@ static int arm_smmu_cmdq_issue_cmdlist(struct arm_smmu_device *smmu,
 	return ret;
 }
 
-static int arm_smmu_cmdq_issue_cmd(struct arm_smmu_device *smmu,
-				   struct arm_smmu_cmdq_ent *ent)
+static int __arm_smmu_cmdq_issue_cmd(struct arm_smmu_device *smmu,
+				     struct arm_smmu_cmdq_ent *ent,
+				     bool sync)
 {
 	u64 cmd[CMDQ_ENT_DWORDS];
 
@@ -1041,26 +1042,19 @@ static int arm_smmu_cmdq_issue_cmd(struct arm_smmu_device *smmu,
 		return -EINVAL;
 	}
 
-	return arm_smmu_cmdq_issue_cmdlist(smmu, cmd, 1, false);
+	return arm_smmu_cmdq_issue_cmdlist(smmu, cmd, 1, sync);
 }
 
-static int __maybe_unused arm_smmu_cmdq_issue_sync(struct arm_smmu_device *smmu)
+static int arm_smmu_cmdq_issue_cmd(struct arm_smmu_device *smmu,
+				   struct arm_smmu_cmdq_ent *ent)
 {
-	return arm_smmu_cmdq_issue_cmdlist(smmu, NULL, 0, true);
+	return __arm_smmu_cmdq_issue_cmd(smmu, ent, false);
 }
 
 static int arm_smmu_cmdq_issue_cmd_with_sync(struct arm_smmu_device *smmu,
 					     struct arm_smmu_cmdq_ent *ent)
 {
-	u64 cmd[CMDQ_ENT_DWORDS];
-
-	if (arm_smmu_cmdq_build_cmd(cmd, ent)) {
-		dev_warn(smmu->dev, "ignoring unknown CMDQ opcode 0x%x\n",
-			 ent->opcode);
-		return -EINVAL;
-	}
-
-	return arm_smmu_cmdq_issue_cmdlist(smmu, cmd, 1, true);
+	return __arm_smmu_cmdq_issue_cmd(smmu, ent, true);
 }
 
 static void arm_smmu_cmdq_batch_add(struct arm_smmu_device *smmu,
@@ -2255,8 +2249,7 @@ static void __arm_smmu_tlb_inv_context(struct arm_smmu_domain *smmu_domain,
 		cmd.opcode	= CMDQ_OP_TLBI_NH_ASID;
 		cmd.tlbi.asid	= ext_asid;
 		cmd.tlbi.vmid	= smmu_domain->s2_cfg.vmid;
-		arm_smmu_cmdq_issue_cmd(smmu, &cmd);
-		arm_smmu_cmdq_issue_sync(smmu);
+		arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
 	} else if (smmu_domain->stage == ARM_SMMU_DOMAIN_S1) {
 		arm_smmu_tlb_inv_asid(smmu, smmu_domain->s1_cfg.cd.asid);
 	} else {
@@ -3853,8 +3846,7 @@ arm_smmu_cache_invalidate(struct iommu_domain *domain, struct device *dev,
 
 	/* Global S1 invalidation */
 	cmd.tlbi.vmid   = smmu_domain->s2_cfg.vmid;
-	arm_smmu_cmdq_issue_cmd(smmu, &cmd);
-	arm_smmu_cmdq_issue_sync(smmu);
+	arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
 	return 0;
 }
 
-- 
2.26.2

