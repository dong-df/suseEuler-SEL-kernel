From 92cf6727e2387110a0a45efcd34461c1b43e5465 Mon Sep 17 00:00:00 2001
From: Zhang Wensheng <zhangwensheng5@huawei.com>
Date: Tue, 31 May 2022 23:19:33 +0800
Subject: [PATCH] driver core: fix deadlock in __driver_attach
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 92cf6727e2387110a0a45efcd34461c1b43e5465
Modified-by-SEL: No


hulk inclusion
category: bugfix
bugzilla: https://gitee.com/openeuler/kernel/issues/I58CRT
CVE: NA

--------------------------------

In __driver_attach function, The lock holding logic is as follows:
...
__driver_attach
if (driver_allows_async_probing(drv))
  device_lock(dev)      // get lock dev
    async_schedule_dev(__driver_attach_async_helper, dev); // func
      async_schedule_node
        async_schedule_node_domain(func)
          entry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);
	  /* when fail or work limit, sync to execute func, but
	     __driver_attach_async_helper will get lock dev as
	     will, which will lead to A-A deadlock.  */
	  if (!entry || atomic_read(&entry_count) > MAX_WORK) {
	    func;
	  else
	    queue_work_node(node, system_unbound_wq, &entry->work)
  device_unlock(dev)

As above show, when it is allowed to do async probes, because of
out of memory or work limit, async work is not be allowed, to do
sync execute instead. it will lead to A-A deadlock because of
__driver_attach_async_helper getting lock dev.

To fix the deadlock, move the async_schedule_dev outside device_lock,
as we can see, in async_schedule_node_domain, the parameter of
queue_work_node is system_unbound_wq, so it can accept concurrent
operations. which will also not change the code logic, and will
not lead to deadlock.

Fixes: ef0ff68351be ("driver core: Probe devices asynchronously instead of the driver")
Signed-off-by: Zhang Wensheng <zhangwensheng5@huawei.com>
Reviewed-by: Hou Tao <houtao1@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 drivers/base/dd.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3e62b2f24bfb..bde049c998de 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -1062,6 +1062,7 @@ static int __driver_attach(struct device *dev, void *data)
 {
 	struct device_driver *drv = data;
 	int ret;
+	bool async = false;
 
 	/*
 	 * Lock device and try to bind to it. We drop the error
@@ -1098,9 +1099,11 @@ static int __driver_attach(struct device *dev, void *data)
 		if (!dev->driver) {
 			get_device(dev);
 			dev->p->async_driver = drv;
-			async_schedule_dev(__driver_attach_async_helper, dev);
+			async = true;
 		}
 		device_unlock(dev);
+		if (async)
+			async_schedule_dev(__driver_attach_async_helper, dev);
 		return 0;
 	}
 
-- 
2.34.1

