From 8be49d1d15b0442b86b0efb519940dde9522b20c Mon Sep 17 00:00:00 2001
From: Yu Jiahua <yujiahua1@huawei.com>
Date: Thu, 20 Jan 2022 12:22:29 +0800
Subject: [PATCH] Revert "sched/idle: Reported an error when an illegal
 negative value is passed"
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 8be49d1d15b0442b86b0efb519940dde9522b20c


hulk inclusion
category: feature
bugzilla: https://gitee.com/openeuler/kernel/issues/I4QU5Z?from=project-issue
CVE: NA

--------------------------------

This patch revert ias feature from open-euler kernel.

This reverts commit fe426fa77d72338c9af7d464bd507eccf62c3f87.

Signed-off-by: Yu Jiahua <Yujiahua1@huawei.com>
Reviewed-by: Chen Hui <judy.chenhui@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 include/linux/kernel.h |  2 +-
 kernel/sched/idle.c    | 10 +++++-----
 kernel/sysctl.c        |  6 +++---
 3 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 601ecfb13690..dace1d9dffa6 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -558,7 +558,7 @@ extern int sysctl_panic_on_stackoverflow;
 
 extern bool crash_kexec_post_notifiers;
 #ifdef CONFIG_IAS_SMART_IDLE
-extern int poll_threshold_ns;
+extern unsigned long poll_threshold_ns;
 #endif
 
 
diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c
index 2e1db13b863f..47781b6a83dd 100644
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@ -18,7 +18,7 @@ extern char __cpuidle_text_start[], __cpuidle_text_end[];
  * Poll_threshold_ns indicates the maximum polling time before
  * entering real idle.
  */
-int poll_threshold_ns;
+unsigned long poll_threshold_ns;
 #endif
 
 /**
@@ -63,9 +63,9 @@ __setup("hlt", cpu_idle_nopoll_setup);
 #ifdef CONFIG_IAS_SMART_IDLE
 /* looping 2000 times is probably microsecond level for 2GHZ CPU*/
 #define MICRO_LEVEL_COUNT 2000
-static inline void delay_relax(int delay_max)
+static inline void delay_relax(unsigned long delay_max)
 {
-	int delay_count = 0;
+	unsigned long delay_count = 0;
 
 	delay_max = (delay_max < MICRO_LEVEL_COUNT) ? delay_max : MICRO_LEVEL_COUNT;
 	while (unlikely(!tif_need_resched()) && delay_count < delay_max) {
@@ -77,7 +77,7 @@ static inline void delay_relax(int delay_max)
 
 static inline void smart_idle_poll(void)
 {
-	int poll_duration = poll_threshold_ns;
+	unsigned long poll_duration = poll_threshold_ns;
 	ktime_t cur, stop;
 
 	if (likely(!poll_duration))
@@ -309,7 +309,7 @@ static void do_idle(void)
 {
 	int cpu = smp_processor_id();
 #ifdef CONFIG_IAS_SMART_IDLE
-	int idle_poll_flag = poll_threshold_ns;
+	unsigned long idle_poll_flag = poll_threshold_ns;
 #endif
 	/*
 	 * If the arch has a polling bit, we maintain an invariant:
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 9bec60bd9fa2..90d9aff1bdb1 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1664,10 +1664,9 @@ static struct ctl_table ias_table[] = {
 	{
 		.procname	= "smart_idle_threshold",
 		.data		= &poll_threshold_ns,
-		.maxlen		= sizeof(int),
+		.maxlen		= sizeof(unsigned long),
 		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
+		.proc_handler	= proc_doulongvec_minmax,
 	},
 #endif
 
@@ -1872,6 +1871,7 @@ static struct ctl_table kern_table[] = {
 		.proc_handler	= sysctl_sched_uclamp_handler,
 	},
 #endif
+
 #ifdef CONFIG_SCHED_AUTOGROUP
 	{
 		.procname	= "sched_autogroup_enabled",
-- 
2.26.2

