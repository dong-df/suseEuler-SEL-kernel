From fa96b57c149061f71a70bd6582d995f6424fbbf4 Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhuacai@loongson.cn>
Date: Tue, 31 May 2022 18:04:11 +0800
Subject: [PATCH] LoongArch: Add build infrastructure
Git-commit: fa96b57c149061f71a70bd6582d995f6424fbbf4
Patch-mainline: v5.19-rc1
References: bsn#12
Modified-by-SEL: Yes, modified per openEuler commit 8bd5550c


Add Kbuild, Makefile, Kconfig and link script for LoongArch build
infrastructure.

Reviewed-by: Guo Ren <guoren@kernel.org>
Reviewed-by: WANG Xuerui <git@xen0n.name>
Reviewed-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 arch/loongarch/Kbuild                         |   6 +
 arch/loongarch/Kconfig                        | 385 ++++++++++++++
 arch/loongarch/Kconfig.debug                  |   0
 arch/loongarch/Makefile                       |  99 ++++
 arch/loongarch/boot/.gitignore                |   2 +
 arch/loongarch/boot/Makefile                  |  16 +
 arch/loongarch/boot/dts/Makefile              |   4 +
 arch/loongarch/include/asm/Kbuild             |  30 ++
 arch/loongarch/include/uapi/asm/Kbuild        |   2 +
 arch/loongarch/kernel/.gitignore              |   2 +
 arch/loongarch/kernel/Makefile                |  21 +
 arch/loongarch/kernel/vmlinux.lds.S           | 116 +++++
 arch/loongarch/lib/Makefile                   |   6 +
 arch/loongarch/mm/Makefile                    |   9 +
 arch/loongarch/pci/Makefile                   |   7 +
 arch/loongarch/vdso/.gitignore                |   2 +
 scripts/subarch.include                       |   2 +-
 tools/arch/loongarch/include/asm/orc_types.h  |  60 +++
 .../loongarch/include/uapi/asm/bitfield.h     |  17 +
 tools/arch/loongarch/include/uapi/asm/inst.h  | 474 ++++++++++++++++++
 20 files changed, 1259 insertions(+), 1 deletion(-)
 create mode 100644 arch/loongarch/Kbuild
 create mode 100644 arch/loongarch/Kconfig
 create mode 100644 arch/loongarch/Kconfig.debug
 create mode 100644 arch/loongarch/Makefile
 create mode 100644 arch/loongarch/boot/.gitignore
 create mode 100644 arch/loongarch/boot/Makefile
 create mode 100644 arch/loongarch/boot/dts/Makefile
 create mode 100644 arch/loongarch/include/asm/Kbuild
 create mode 100644 arch/loongarch/include/uapi/asm/Kbuild
 create mode 100644 arch/loongarch/kernel/.gitignore
 create mode 100644 arch/loongarch/kernel/Makefile
 create mode 100644 arch/loongarch/kernel/vmlinux.lds.S
 create mode 100644 arch/loongarch/lib/Makefile
 create mode 100644 arch/loongarch/mm/Makefile
 create mode 100644 arch/loongarch/pci/Makefile
 create mode 100644 arch/loongarch/vdso/.gitignore
 create mode 100644 tools/arch/loongarch/include/asm/orc_types.h
 create mode 100644 tools/arch/loongarch/include/uapi/asm/bitfield.h
 create mode 100644 tools/arch/loongarch/include/uapi/asm/inst.h

diff --git a/arch/loongarch/Kbuild b/arch/loongarch/Kbuild
new file mode 100644
index 000000000000..ab5373d0a24f
--- /dev/null
+++ b/arch/loongarch/Kbuild
@@ -0,0 +1,6 @@
+obj-y += kernel/
+obj-y += mm/
+obj-y += vdso/
+
+# for cleaning
+subdir- += boot
diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
new file mode 100644
index 000000000000..650c02314f6e
--- /dev/null
+++ b/arch/loongarch/Kconfig
@@ -0,0 +1,385 @@
+# SPDX-License-Identifier: GPL-2.0
+config LOONGARCH
+	bool
+	default y
+	select ACPI_SYSTEM_POWER_STATES_SUPPORT	if ACPI
+	select ARCH_BINFMT_ELF_STATE
+	select ARCH_ENABLE_MEMORY_HOTPLUG
+	select ARCH_ENABLE_MEMORY_HOTREMOVE
+	select ARCH_HAS_ACPI_TABLE_UPGRADE	if ACPI
+	select ARCH_HAS_PTE_SPECIAL
+	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
+	select ARCH_INLINE_READ_LOCK if !PREEMPTION
+	select ARCH_INLINE_READ_LOCK_BH if !PREEMPTION
+	select ARCH_INLINE_READ_LOCK_IRQ if !PREEMPTION
+	select ARCH_INLINE_READ_LOCK_IRQSAVE if !PREEMPTION
+	select ARCH_INLINE_READ_UNLOCK if !PREEMPTION
+	select ARCH_INLINE_READ_UNLOCK_BH if !PREEMPTION
+	select ARCH_INLINE_READ_UNLOCK_IRQ if !PREEMPTION
+	select ARCH_INLINE_READ_UNLOCK_IRQRESTORE if !PREEMPTION
+	select ARCH_INLINE_WRITE_LOCK if !PREEMPTION
+	select ARCH_INLINE_WRITE_LOCK_BH if !PREEMPTION
+	select ARCH_INLINE_WRITE_LOCK_IRQ if !PREEMPTION
+	select ARCH_INLINE_WRITE_LOCK_IRQSAVE if !PREEMPTION
+	select ARCH_INLINE_WRITE_UNLOCK if !PREEMPTION
+	select ARCH_INLINE_WRITE_UNLOCK_BH if !PREEMPTION
+	select ARCH_INLINE_WRITE_UNLOCK_IRQ if !PREEMPTION
+	select ARCH_INLINE_WRITE_UNLOCK_IRQRESTORE if !PREEMPTION
+	select ARCH_INLINE_SPIN_TRYLOCK if !PREEMPTION
+	select ARCH_INLINE_SPIN_TRYLOCK_BH if !PREEMPTION
+	select ARCH_INLINE_SPIN_LOCK if !PREEMPTION
+	select ARCH_INLINE_SPIN_LOCK_BH if !PREEMPTION
+	select ARCH_INLINE_SPIN_LOCK_IRQ if !PREEMPTION
+	select ARCH_INLINE_SPIN_LOCK_IRQSAVE if !PREEMPTION
+	select ARCH_INLINE_SPIN_UNLOCK if !PREEMPTION
+	select ARCH_INLINE_SPIN_UNLOCK_BH if !PREEMPTION
+	select ARCH_INLINE_SPIN_UNLOCK_IRQ if !PREEMPTION
+	select ARCH_INLINE_SPIN_UNLOCK_IRQRESTORE if !PREEMPTION
+	select ARCH_MIGHT_HAVE_PC_PARPORT
+	select ARCH_MIGHT_HAVE_PC_SERIO
+	select ARCH_SPARSEMEM_ENABLE
+	select ARCH_SUPPORTS_ACPI
+	select ARCH_SUPPORTS_ATOMIC_RMW
+	select ARCH_SUPPORTS_HUGETLBFS
+	select ARCH_USE_BUILTIN_BSWAP
+	select ARCH_USE_CMPXCHG_LOCKREF
+	select ARCH_USE_QUEUED_RWLOCKS
+	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT
+	select ARCH_WANTS_NO_INSTR
+	select BUILDTIME_TABLE_SORT
+	select COMMON_CLK
+	select GENERIC_CLOCKEVENTS
+	select GENERIC_CMOS_UPDATE
+	select GENERIC_CPU_AUTOPROBE
+	select GENERIC_ENTRY
+	select GENERIC_FIND_FIRST_BIT
+	select GENERIC_GETTIMEOFDAY
+	select GENERIC_IRQ_MULTI_HANDLER
+	select GENERIC_IRQ_PROBE
+	select GENERIC_IRQ_SHOW
+	select GENERIC_LIB_ASHLDI3
+	select GENERIC_LIB_ASHRDI3
+	select GENERIC_LIB_CMPDI2
+	select GENERIC_LIB_LSHRDI3
+	select GENERIC_LIB_UCMPDI2
+	select GENERIC_PCI_IOMAP
+	select GENERIC_SCHED_CLOCK
+	select GENERIC_TIME_VSYSCALL
+	select GPIOLIB
+	select HAVE_ARCH_AUDITSYSCALL
+	select HAVE_ARCH_COMPILER_H
+	select HAVE_ARCH_MMAP_RND_BITS if MMU
+	select HAVE_ARCH_SECCOMP_FILTER
+	select HAVE_ARCH_TRACEHOOK
+	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
+	select HAVE_ASM_MODVERSIONS
+	select HAVE_CONTEXT_TRACKING
+	select HAVE_COPY_THREAD_TLS
+	select HAVE_DEBUG_STACKOVERFLOW
+	select HAVE_DMA_CONTIGUOUS
+	select HAVE_EXIT_THREAD
+	select HAVE_FAST_GUP
+	select HANDLE_DOMAIN_IRQ
+	select HAVE_GENERIC_VDSO
+	select HAVE_IOREMAP_PROT
+	select HAVE_IRQ_EXIT_ON_IRQ_STACK
+	select HAVE_IRQ_TIME_ACCOUNTING
+	select HAVE_MEMBLOCK
+	select HAVE_MEMBLOCK_NODE_MAP
+	select HAVE_MOD_ARCH_SPECIFIC
+	select HAVE_NMI
+	select HAVE_PERF_EVENTS
+	select HAVE_REGS_AND_STACK_ACCESS_API
+	select HAVE_RSEQ
+	select HAVE_SYSCALL_TRACEPOINTS
+	select HAVE_TIF_NOHZ
+	select HAVE_VIRT_CPU_ACCOUNTING_GEN
+	select IRQ_FORCED_THREADING
+	select IRQ_LOONGARCH_CPU
+	select MODULES_USE_ELF_RELA if MODULES
+	select OF
+	select OF_EARLY_FLATTREE
+	select PERF_USE_VMALLOC
+	select RTC_LIB
+	select SPARSE_IRQ
+	select SYSCTL_EXCEPTION_TRACE
+	select SWIOTLB
+	select TRACE_IRQFLAGS_SUPPORT
+	select USER_STACKTRACE_SUPPORT
+	select ZONE_DMA32
+
+config 32BIT
+	bool
+
+config 64BIT
+	def_bool y
+
+config USE_PERCPU_NUMA_NODE_ID
+	def_bool y
+	depends on NUMA
+
+config CPU_HAS_FPU
+	bool
+	default y
+
+config CPU_HAS_PREFETCH
+	bool
+	default y
+
+config GENERIC_CALIBRATE_DELAY
+	def_bool y
+
+config GENERIC_CSUM
+	def_bool y
+
+config GENERIC_HWEIGHT
+	def_bool y
+
+config L1_CACHE_SHIFT
+	int
+	default "6"
+
+config LOCKDEP_SUPPORT
+	bool
+	default y
+
+# MACH_LOONGSON32 and MACH_LOONGSON64 are delibrately carried over from the
+# MIPS Loongson code, to preserve Loongson-specific code paths in drivers that
+# are shared between architectures, and specifically expecting the symbols.
+config MACH_LOONGSON32
+	def_bool 32BIT
+
+config MACH_LOONGSON64
+	def_bool 64BIT
+
+config PAGE_SIZE_4KB
+	bool
+
+config PAGE_SIZE_16KB
+	bool
+
+config PAGE_SIZE_64KB
+	bool
+
+config PGTABLE_2LEVEL
+	bool
+
+config PGTABLE_3LEVEL
+	bool
+
+config PGTABLE_4LEVEL
+	bool
+
+config PGTABLE_LEVELS
+	int
+	default 2 if PGTABLE_2LEVEL
+	default 3 if PGTABLE_3LEVEL
+	default 4 if PGTABLE_4LEVEL
+
+config SCHED_OMIT_FRAME_POINTER
+	bool
+	default y
+
+menu "Kernel type and options"
+
+source "kernel/Kconfig.hz"
+
+choice
+	prompt "Page Table Layout"
+	default 16KB_2LEVEL if 32BIT
+	default 16KB_3LEVEL if 64BIT
+	help
+	  Allows choosing the page table layout, which is a combination
+	  of page size and page table levels. The size of virtual memory
+	  address space are determined by the page table layout.
+
+config 4KB_3LEVEL
+	bool "4KB with 3 levels"
+	select PAGE_SIZE_4KB
+	select PGTABLE_3LEVEL
+	help
+	  This option selects 4KB page size with 3 level page tables, which
+	  support a maximum of 39 bits of application virtual memory.
+
+config 4KB_4LEVEL
+	bool "4KB with 4 levels"
+	select PAGE_SIZE_4KB
+	select PGTABLE_4LEVEL
+	help
+	  This option selects 4KB page size with 4 level page tables, which
+	  support a maximum of 48 bits of application virtual memory.
+
+config 16KB_2LEVEL
+	bool "16KB with 2 levels"
+	select PAGE_SIZE_16KB
+	select PGTABLE_2LEVEL
+	help
+	  This option selects 16KB page size with 2 level page tables, which
+	  support a maximum of 36 bits of application virtual memory.
+
+config 16KB_3LEVEL
+	bool "16KB with 3 levels"
+	select PAGE_SIZE_16KB
+	select PGTABLE_3LEVEL
+	help
+	  This option selects 16KB page size with 3 level page tables, which
+	  support a maximum of 47 bits of application virtual memory.
+
+config 64KB_2LEVEL
+	bool "64KB with 2 levels"
+	select PAGE_SIZE_64KB
+	select PGTABLE_2LEVEL
+	help
+	  This option selects 64KB page size with 2 level page tables, which
+	  support a maximum of 42 bits of application virtual memory.
+
+config 64KB_3LEVEL
+	bool "64KB with 3 levels"
+	select PAGE_SIZE_64KB
+	select PGTABLE_3LEVEL
+	help
+	  This option selects 64KB page size with 3 level page tables, which
+	  support a maximum of 55 bits of application virtual memory.
+
+endchoice
+
+config CMDLINE
+	string "Built-in kernel command line"
+	help
+	  For most platforms, the arguments for the kernel's command line
+	  are provided at run-time, during boot. However, there are cases
+	  where either no arguments are being provided or the provided
+	  arguments are insufficient or even invalid.
+
+	  When that occurs, it is possible to define a built-in command
+	  line here and choose how the kernel should use it later on.
+
+choice
+	prompt "Kernel command line type"
+	default CMDLINE_BOOTLOADER
+	help
+	  Choose how the kernel will handle the provided built-in command
+	  line.
+
+config CMDLINE_BOOTLOADER
+	bool "Use bootloader kernel arguments if available"
+	help
+	  Prefer the command-line passed by the boot loader if available.
+	  Use the built-in command line as fallback in case we get nothing
+	  during boot. This is the default behaviour.
+
+config CMDLINE_EXTEND
+	bool "Use built-in to extend bootloader kernel arguments"
+	help
+	  The command-line arguments provided during boot will be
+	  appended to the built-in command line. This is useful in
+	  cases where the provided arguments are insufficient and
+	  you don't want to or cannot modify them.
+
+config CMDLINE_FORCE
+	bool "Always use the built-in kernel command string"
+	help
+	  Always use the built-in command line, even if we get one during
+	  boot. This is useful in case you need to override the provided
+	  command line on systems where you don't have or want control
+	  over it.
+
+endchoice
+
+config DMI
+	bool "Enable DMI scanning"
+	select DMI_SCAN_MACHINE_NON_EFI_FALLBACK
+	default y
+	help
+	  This enables SMBIOS/DMI feature for systems, and scanning of
+	  DMI to identify machine quirks.
+
+config EFI
+	bool "EFI runtime service support"
+	select UCS2_STRING
+	select EFI_PARAMS_FROM_FDT
+	select EFI_RUNTIME_WRAPPERS
+	help
+	  This enables the kernel to use EFI runtime services that are
+	  available (such as the EFI variable services).
+
+config FORCE_MAX_ZONEORDER
+	int "Maximum zone order"
+	range 14 64 if PAGE_SIZE_64KB
+	default "14" if PAGE_SIZE_64KB
+	range 12 64 if PAGE_SIZE_16KB
+	default "12" if PAGE_SIZE_16KB
+	range 11 64
+	default "11"
+	help
+	  The kernel memory allocator divides physically contiguous memory
+	  blocks into "zones", where each zone is a power of two number of
+	  pages.  This option selects the largest power of two that the kernel
+	  keeps in the memory allocator.  If you need to allocate very large
+	  blocks of physically contiguous memory, then you may need to
+	  increase this value.
+
+	  This config option is actually maximum order plus one. For example,
+	  a value of 11 means that the largest free memory block is 2^10 pages.
+
+	  The page size is not necessarily 4KB.  Keep this in mind
+	  when choosing a value for this option.
+
+config SECCOMP
+	bool "Enable seccomp to safely compute untrusted bytecode"
+	depends on PROC_FS
+	default y
+	help
+	  This kernel feature is useful for number crunching applications
+	  that may need to compute untrusted bytecode during their
+	  execution. By using pipes or other transports made available to
+	  the process as file descriptors supporting the read/write
+	  syscalls, it's possible to isolate those applications in
+	  their own address space using seccomp. Once seccomp is
+	  enabled via /proc/<pid>/seccomp, it cannot be disabled
+	  and the task is only allowed to execute a few safe syscalls
+	  defined by each seccomp mode.
+
+	  If unsure, say Y. Only embedded should say N here.
+
+endmenu
+
+config ARCH_SELECT_MEMORY_MODEL
+	def_bool y
+
+config ARCH_FLATMEM_ENABLE
+	def_bool y
+
+config ARCH_SPARSEMEM_ENABLE
+	def_bool y
+	help
+	  Say Y to support efficient handling of sparse physical memory,
+	  for architectures which are either NUMA (Non-Uniform Memory Access)
+	  or have huge holes in the physical address space for other reasons.
+	  See <file:Documentation/vm/numa.rst> for more.
+
+config ARCH_ENABLE_THP_MIGRATION
+	def_bool y
+	depends on TRANSPARENT_HUGEPAGE
+
+config ARCH_MEMORY_PROBE
+	def_bool y
+	depends on MEMORY_HOTPLUG
+
+config MMU
+	bool
+	default y
+
+config ARCH_MMAP_RND_BITS_MIN
+	default 12
+
+config ARCH_MMAP_RND_BITS_MAX
+	default 18
+
+menu "Power management options"
+
+source "drivers/acpi/Kconfig"
+
+endmenu
+
+source "drivers/firmware/Kconfig"
diff --git a/arch/loongarch/Kconfig.debug b/arch/loongarch/Kconfig.debug
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/arch/loongarch/Makefile b/arch/loongarch/Makefile
new file mode 100644
index 000000000000..037b5bd3fd6d
--- /dev/null
+++ b/arch/loongarch/Makefile
@@ -0,0 +1,99 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Author: Huacai Chen <chenhuacai@loongson.cn>
+# Copyright (C) 2020-2022 Loongson Technology Corporation Limited
+
+boot	:= arch/loongarch/boot
+
+KBUILD_IMAGE	= $(boot)/vmlinux
+
+#
+# Select the object file format to substitute into the linker script.
+#
+64bit-tool-archpref	= loongarch64
+32bit-bfd		= elf32-loongarch
+64bit-bfd		= elf64-loongarch
+32bit-emul		= elf32loongarch
+64bit-emul		= elf64loongarch
+
+ifdef CONFIG_64BIT
+tool-archpref		= $(64bit-tool-archpref)
+UTS_MACHINE		:= loongarch64
+endif
+
+ifneq ($(SUBARCH),$(ARCH))
+  ifeq ($(CROSS_COMPILE),)
+    CROSS_COMPILE := $(call cc-cross-prefix, $(tool-archpref)-linux-  $(tool-archpref)-linux-gnu-  $(tool-archpref)-unknown-linux-gnu-)
+  endif
+endif
+
+ifdef CONFIG_64BIT
+ld-emul			= $(64bit-emul)
+cflags-y		+= -mabi=lp64s
+endif
+
+cflags-y			+= -G0 -pipe -msoft-float
+LDFLAGS_vmlinux			+= -G0 -static -n -nostdlib
+KBUILD_AFLAGS_KERNEL		+= -Wa,-mla-global-with-pcrel
+KBUILD_CFLAGS_KERNEL		+= -Wa,-mla-global-with-pcrel
+KBUILD_AFLAGS_MODULE		+= -Wa,-mla-global-with-abs
+KBUILD_CFLAGS_MODULE		+= -fplt -Wa,-mla-global-with-abs,-mla-local-with-abs
+
+cflags-y += -ffreestanding
+cflags-y += $(call cc-option, -mno-check-zero-division)
+
+load-y		= 0x9000000000200000
+bootvars-y	= VMLINUX_LOAD_ADDRESS=$(load-y)
+
+KBUILD_AFLAGS	+= $(cflags-y)
+KBUILD_CFLAGS	+= $(cflags-y)
+KBUILD_CPPFLAGS += -DVMLINUX_LOAD_ADDRESS=$(load-y)
+
+# This is required to get dwarf unwinding tables into .debug_frame
+# instead of .eh_frame so we don't discard them.
+KBUILD_CFLAGS += -fno-asynchronous-unwind-tables
+
+# Don't emit unaligned accesses.
+# Not all LoongArch cores support unaligned access, and as kernel we can't
+# rely on others to provide emulation for these accesses.
+KBUILD_CFLAGS += $(call cc-option,-mstrict-align)
+
+KBUILD_CFLAGS += -isystem $(shell $(CC) -print-file-name=include)
+
+KBUILD_LDFLAGS	+= -m $(ld-emul)
+
+ifdef CONFIG_LOONGARCH
+CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -x c /dev/null | \
+	egrep -vw '__GNUC_(MINOR_|PATCHLEVEL_)?_' | \
+	sed -e "s/^\#define /-D'/" -e "s/ /'='/" -e "s/$$/'/" -e 's/\$$/&&/g')
+endif
+
+head-y := arch/loongarch/kernel/head.o
+
+core-y += arch/loongarch/
+libs-y += arch/loongarch/lib/
+
+ifeq ($(KBUILD_EXTMOD),)
+prepare: vdso_prepare
+vdso_prepare: prepare0
+	$(Q)$(MAKE) $(build)=arch/loongarch/vdso include/generated/vdso-offsets.h
+endif
+
+PHONY += vdso_install
+vdso_install:
+	$(Q)$(MAKE) $(build)=arch/loongarch/vdso $@
+
+all:	$(KBUILD_IMAGE)
+
+$(KBUILD_IMAGE): vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(bootvars-y) $@
+
+install:
+	$(Q)install -D -m 755 $(KBUILD_IMAGE) $(INSTALL_PATH)/vmlinux-$(KERNELRELEASE)
+	$(Q)install -D -m 644 .config $(INSTALL_PATH)/config-$(KERNELRELEASE)
+	$(Q)install -D -m 644 System.map $(INSTALL_PATH)/System.map-$(KERNELRELEASE)
+
+define archhelp
+	echo '  install              - install kernel into $(INSTALL_PATH)'
+	echo
+endef
diff --git a/arch/loongarch/boot/.gitignore b/arch/loongarch/boot/.gitignore
new file mode 100644
index 000000000000..49423ee96ef3
--- /dev/null
+++ b/arch/loongarch/boot/.gitignore
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+vmlinux*
diff --git a/arch/loongarch/boot/Makefile b/arch/loongarch/boot/Makefile
new file mode 100644
index 000000000000..0125b17edc98
--- /dev/null
+++ b/arch/loongarch/boot/Makefile
@@ -0,0 +1,16 @@
+#
+# arch/loongarch/boot/Makefile
+#
+# Copyright (C) 2020-2022 Loongson Technology Corporation Limited
+#
+
+drop-sections := .comment .note .options .note.gnu.build-id
+strip-flags   := $(addprefix --remove-section=,$(drop-sections)) -S
+OBJCOPYFLAGS_vmlinux.efi := -O binary $(strip-flags)
+
+targets := vmlinux
+quiet_cmd_strip = STRIP	  $@
+      cmd_strip = $(STRIP) -s -o $@ $<
+
+$(obj)/vmlinux: vmlinux FORCE
+	$(call if_changed,strip)
diff --git a/arch/loongarch/boot/dts/Makefile b/arch/loongarch/boot/dts/Makefile
new file mode 100644
index 000000000000..5f1f55e911ad
--- /dev/null
+++ b/arch/loongarch/boot/dts/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0-only
+dtstree	:= $(srctree)/$(src)
+
+dtb-y := $(patsubst $(dtstree)/%.dts,%.dtb, $(wildcard $(dtstree)/*.dts))
diff --git a/arch/loongarch/include/asm/Kbuild b/arch/loongarch/include/asm/Kbuild
new file mode 100644
index 000000000000..83bc0681e72b
--- /dev/null
+++ b/arch/loongarch/include/asm/Kbuild
@@ -0,0 +1,30 @@
+# SPDX-License-Identifier: GPL-2.0
+generic-y += dma-contiguous.h
+generic-y += export.h
+generic-y += parport.h
+generic-y += early_ioremap.h
+generic-y += qrwlock.h
+generic-y += qrwlock_types.h
+generic-y += spinlock.h
+generic-y += spinlock_types.h
+generic-y += rwsem.h
+generic-y += segment.h
+generic-y += user.h
+generic-y += stat.h
+generic-y += fcntl.h
+generic-y += ioctl.h
+generic-y += ioctls.h
+generic-y += mman.h
+generic-y += msgbuf.h
+generic-y += sembuf.h
+generic-y += shmbuf.h
+generic-y += statfs.h
+generic-y += socket.h
+generic-y += sockios.h
+generic-y += termios.h
+generic-y += termbits.h
+generic-y += poll.h
+generic-y += param.h
+generic-y += posix_types.h
+generic-y += resource.h
+generic-y += kvm_para.h
diff --git a/arch/loongarch/include/uapi/asm/Kbuild b/arch/loongarch/include/uapi/asm/Kbuild
new file mode 100644
index 000000000000..4aa680ca2e5f
--- /dev/null
+++ b/arch/loongarch/include/uapi/asm/Kbuild
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+generic-y += kvm_para.h
diff --git a/arch/loongarch/kernel/.gitignore b/arch/loongarch/kernel/.gitignore
new file mode 100644
index 000000000000..bbb90f92d051
--- /dev/null
+++ b/arch/loongarch/kernel/.gitignore
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+vmlinux.lds
diff --git a/arch/loongarch/kernel/Makefile b/arch/loongarch/kernel/Makefile
new file mode 100644
index 000000000000..e5a3b2fb9961
--- /dev/null
+++ b/arch/loongarch/kernel/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Linux/LoongArch kernel.
+#
+
+extra-y		:= head.o vmlinux.lds
+
+obj-y		+= cpu-probe.o cacheinfo.o env.o setup.o entry.o genex.o \
+		   traps.o irq.o idle.o process.o dma.o mem.o io.o reset.o switch.o \
+		   elf.o syscall.o signal.o time.o topology.o inst.o ptrace.o vdso.o
+
+obj-$(CONFIG_ACPI)		+= acpi.o
+obj-$(CONFIG_EFI) 		+= efi.o
+
+obj-$(CONFIG_CPU_HAS_FPU)	+= fpu.o
+
+obj-$(CONFIG_MODULES)		+= module.o module-sections.o
+
+obj-$(CONFIG_PROC_FS)		+= proc.o
+
+CPPFLAGS_vmlinux.lds		:= $(KBUILD_CFLAGS)
diff --git a/arch/loongarch/kernel/vmlinux.lds.S b/arch/loongarch/kernel/vmlinux.lds.S
new file mode 100644
index 000000000000..f6ce24f403c2
--- /dev/null
+++ b/arch/loongarch/kernel/vmlinux.lds.S
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/sizes.h>
+#include <asm/asm-offsets.h>
+#include <asm/thread_info.h>
+
+#define PAGE_SIZE _PAGE_SIZE
+
+/*
+ * Put .bss..swapper_pg_dir as the first thing in .bss. This will
+ * ensure that it has .bss alignment (64K).
+ */
+#define BSS_FIRST_SECTIONS *(.bss..swapper_pg_dir)
+
+#include <asm-generic/vmlinux.lds.h>
+
+/*
+ * Max avaliable Page Size is 64K, so we set SectionAlignment
+ * field of EFI application to 64K.
+ */
+PECOFF_FILE_ALIGN = 0x200;
+PECOFF_SEGMENT_ALIGN = 0x10000;
+
+OUTPUT_ARCH(loongarch)
+ENTRY(kernel_entry)
+PHDRS {
+	text PT_LOAD FLAGS(7);	/* RWX */
+	note PT_NOTE FLAGS(4);	/* R__ */
+}
+
+jiffies	 = jiffies_64;
+
+SECTIONS
+{
+	. = VMLINUX_LOAD_ADDRESS;
+
+	_text = .;
+	HEAD_TEXT_SECTION
+
+	. = ALIGN(PECOFF_SEGMENT_ALIGN);
+	.text : {
+		TEXT_TEXT
+		SCHED_TEXT
+		CPUIDLE_TEXT
+		LOCK_TEXT
+		KPROBES_TEXT
+		IRQENTRY_TEXT
+		SOFTIRQENTRY_TEXT
+		*(.fixup)
+		*(.gnu.warning)
+	} :text = 0
+	. = ALIGN(PECOFF_SEGMENT_ALIGN);
+	_etext = .;
+
+	EXCEPTION_TABLE(16)
+
+	. = ALIGN(PECOFF_SEGMENT_ALIGN);
+	__init_begin = .;
+	__inittext_begin = .;
+
+	INIT_TEXT_SECTION(PAGE_SIZE)
+	.exit.text : {
+		EXIT_TEXT
+	}
+
+	. = ALIGN(PECOFF_SEGMENT_ALIGN);
+	__inittext_end = .;
+
+	__initdata_begin = .;
+
+	INIT_DATA_SECTION(16)
+	.exit.data : {
+		EXIT_DATA
+	}
+
+	.init.bss : {
+		*(.init.bss)
+	}
+	. = ALIGN(PECOFF_SEGMENT_ALIGN);
+	__initdata_end = .;
+
+	__init_end = .;
+
+	_sdata = .;
+	RO_DATA(4096)
+	RW_DATA(1 << CONFIG_L1_CACHE_SHIFT, PAGE_SIZE, THREAD_SIZE)
+
+	.sdata : {
+		*(.sdata)
+	}
+	.edata_padding : { BYTE(0); . = ALIGN(PECOFF_FILE_ALIGN); }
+	_edata =  .;
+
+	BSS_SECTION(0, SZ_64K, 8)
+	. = ALIGN(PECOFF_SEGMENT_ALIGN);
+
+	_end = .;
+
+	STABS_DEBUG
+	DWARF_DEBUG
+
+	.gptab.sdata : {
+		*(.gptab.data)
+		*(.gptab.sdata)
+	}
+	.gptab.sbss : {
+		*(.gptab.bss)
+		*(.gptab.sbss)
+	}
+
+	DISCARDS
+	/DISCARD/ : {
+		*(.gnu.attributes)
+		*(.options)
+		*(.eh_frame)
+	}
+}
diff --git a/arch/loongarch/lib/Makefile b/arch/loongarch/lib/Makefile
new file mode 100644
index 000000000000..e36635fccb69
--- /dev/null
+++ b/arch/loongarch/lib/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for LoongArch-specific library files.
+#
+
+lib-y	+= delay.o clear_user.o copy_user.o dump_tlb.o
diff --git a/arch/loongarch/mm/Makefile b/arch/loongarch/mm/Makefile
new file mode 100644
index 000000000000..8ffc6383f836
--- /dev/null
+++ b/arch/loongarch/mm/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Linux/LoongArch-specific parts of the memory manager.
+#
+
+obj-y				+= init.o cache.o tlb.o tlbex.o extable.o \
+				   fault.o ioremap.o maccess.o mmap.o pgtable.o page.o
+
+obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
diff --git a/arch/loongarch/pci/Makefile b/arch/loongarch/pci/Makefile
new file mode 100644
index 000000000000..8101ef3df71c
--- /dev/null
+++ b/arch/loongarch/pci/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the PCI specific kernel interface routines under Linux.
+#
+
+obj-y				+= pci.o
+obj-$(CONFIG_ACPI)		+= acpi.o
diff --git a/arch/loongarch/vdso/.gitignore b/arch/loongarch/vdso/.gitignore
new file mode 100644
index 000000000000..652e31d82582
--- /dev/null
+++ b/arch/loongarch/vdso/.gitignore
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+vdso.lds
diff --git a/scripts/subarch.include b/scripts/subarch.include
index 650682821126..c79e0d0b1a19 100644
--- a/scripts/subarch.include
+++ b/scripts/subarch.include
@@ -10,4 +10,4 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
 				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
 				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
 				  -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ \
-				  -e s/riscv.*/riscv/)
+				  -e s/riscv.*/riscv/ -e s/loongarch.*/loongarch/)
diff --git a/tools/arch/loongarch/include/asm/orc_types.h b/tools/arch/loongarch/include/asm/orc_types.h
new file mode 100644
index 000000000000..999a6f1e7a8c
--- /dev/null
+++ b/tools/arch/loongarch/include/asm/orc_types.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2017 Josh Poimboeuf <jpoimboe@redhat.com>
+ * Copyright (C) 2020 Loongson Technology Corporation Limited
+ */
+
+#ifndef _ASM_ORC_TYPES_H
+#define _ASM_ORC_TYPES_H
+
+#include <linux/types.h>
+#include <linux/compiler.h>
+
+/*
+ * The ORC_REG_* registers are base registers which are used to find other
+ * registers on the stack.
+ *
+ * ORC_REG_PREV_SP, also known as DWARF Call Frame Address (CFA), is the
+ * address of the previous frame: the caller's SP before it called the current
+ * function.
+ *
+ * ORC_REG_UNDEFINED means the corresponding register's value didn't change in
+ * the current frame.
+ *
+ * The most commonly used base registers are SP and FP -- which the previous SP
+ * is usually based on -- and PREV_SP and UNDEFINED -- which the previous FP is
+ * usually based on.
+ */
+#define ORC_REG_UNDEFINED		0
+#define ORC_REG_PREV_SP			1
+#define ORC_REG_SP			2
+#define ORC_REG_FP			3
+#define ORC_REG_MAX			15
+
+#define UNWIND_HINT_TYPE_SAVE		4
+#define UNWIND_HINT_TYPE_RESTORE	5
+
+#ifndef __ASSEMBLY__
+/*
+ * This struct is more or less a vastly simplified version of the DWARF Call
+ * Frame Information standard.  It contains only the necessary parts of DWARF
+ * CFI, simplified for ease of access by the in-kernel unwinder.  It tells the
+ * unwinder how to find the previous SP and FP (and sometimes entry regs) on
+ * the stack for a given code address.  Each instance of the struct corresponds
+ * to one or more code locations.
+ */
+struct orc_entry {
+	signed short	sp_offset;
+	signed short	fp_offset;
+	signed short    ra_offset;
+	unsigned int	sp_reg:4;
+	unsigned int	fp_reg:4;
+	unsigned int	ra_reg:4;
+	unsigned int	type:2;
+	unsigned int	end:1;
+	unsigned int	unused:1;
+};
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_ORC_TYPES_H */
diff --git a/tools/arch/loongarch/include/uapi/asm/bitfield.h b/tools/arch/loongarch/include/uapi/asm/bitfield.h
new file mode 100644
index 000000000000..1bdadee88617
--- /dev/null
+++ b/tools/arch/loongarch/include/uapi/asm/bitfield.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
+/*
+* Copyright (C) 2020 Loongson Technology Corporation Limited
+*
+* Author: Hanlu Li <lihanlu@loongson.cn>
+*/
+#ifndef __UAPI_ASM_BITFIELD_H
+#define __UAPI_ASM_BITFIELD_H
+
+/*
+ *  * Damn ...  bitfields depend from byteorder :-(
+ *   */
+#define __BITFIELD_FIELD(field, more)					\
+	more								\
+	field;
+
+#endif /* __UAPI_ASM_BITFIELD_H */
diff --git a/tools/arch/loongarch/include/uapi/asm/inst.h b/tools/arch/loongarch/include/uapi/asm/inst.h
new file mode 100644
index 000000000000..de8c554bb7aa
--- /dev/null
+++ b/tools/arch/loongarch/include/uapi/asm/inst.h
@@ -0,0 +1,474 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Format of an instruction in memory.
+ *
+ * Copyright (C) 2020 Loongson Technology Corporation Limited
+ */
+#ifndef _UAPI_ASM_INST_H
+#define _UAPI_ASM_INST_H
+
+#include <asm/bitfield.h>
+
+enum reg0_op {
+	tlbclr_op = 0x19208, gtlbclr_op=0x19208,
+	tlbflush_op = 0x19209, gtlbflush_op=0x19209,
+	tlbsrch_op = 0x1920a, gtlbsrch_op=0x1920a,
+	tlbrd_op = 0x1920b, gtlbrd_op=0x1920b,
+	tlbwr_op = 0x1920c, gtlbwr_op=0x1920c,
+	tlbfill_op = 0x1920d, gtlbfill_op=0x1920d,
+	ertn_op = 0x1920e,
+};
+
+enum reg0i15_op {
+	break_op = 0x54, dbcl_op, syscall_op, hypcall_op,
+	idle_op = 0xc91, dbar_op = 0x70e4, ibar_op,
+};
+
+enum reg0i26_op {
+	b_op = 0x14, bl_op,
+};
+
+enum reg1i20_op {
+	lu12iw_op = 0xa, lu32id_op, pcaddi_op, pcalau12i_op,
+	pcaddu12i_op, pcaddu18i_op,
+};
+
+enum reg1i21_op {
+	beqz_op = 0x10, bnez_op, bceqz_op, bcnez_op=0x12, jiscr0_op=0x12, jiscr1_op=0x12,
+};
+
+enum reg2_op {
+	gr2scr_op = 0x2, scr2gr_op, clow_op,
+	clzw_op, ctow_op, ctzw_op, clod_op,
+	clzd_op, ctod_op, ctzd_op, revb2h_op,
+	revb4h_op, revb2w_op, revbd_op, revh2w_op,
+	revhd_op, bitrev4b_op, bitrev8b_op, bitrevw_op,
+	bitrevd_op, extwh_op, extwb_op, rdtimelw_op,
+	rdtimehw_op, rdtimed_op, cpucfg_op,
+	iocsrrdb_op = 0x19200, iocsrrdh_op, iocsrrdw_op, iocsrrdd_op,
+	iocsrwrb_op, iocsrwrh_op, iocsrwrw_op, iocsrwrd_op,
+	movgr2fcsr_op = 0x4530, movfcsr2gr_op = 0x4532,
+	movgr2cf_op = 0x4536, movcf2gr_op = 0x4537,
+};
+
+enum reg2ui3_op {
+	rotrib_op = 0x261, rcrib_op = 0x281,
+};
+
+enum reg2ui4_op {
+	rotrih_op = 0x131, rcrih_op = 0x141,
+};
+
+enum reg2ui5_op {
+	slliw_op = 0x81, srliw_op = 0x89, sraiw_op = 0x91, rotriw_op = 0x99,
+	rcriw_op = 0xa1,
+};
+
+enum reg2ui6_op {
+	sllid_op = 0x41, srlid_op = 0x45, sraid_op = 0x49, rotrid_op = 0x4d,
+	rcrid_op = 0x51,
+};
+
+enum reg2ui12_op {
+	andi_op = 0xd, ori_op, xori_op,
+};
+
+enum reg2lsbw_op {
+	bstrinsw_op = 0x3, bstrpickw_op = 0x3,
+};
+
+enum reg2lsbd_op {
+	bstrinsd_op = 0x2, bstrpickd_op = 0x3,
+};
+
+enum reg2i8_op {
+	lddir_op = 0x190, ldpte_op,
+};
+
+enum reg2i8idx1_op {
+	vstelmd_op = 0x622,
+};
+
+enum reg2i8idx2_op {
+	vstelmw_op = 0x312, xvstelmd_op = 0x331,
+};
+
+enum reg2i8idx3_op {
+	vstelmh_op = 0x18a, xvstelmw_op = 0x199,
+};
+
+enum reg2i8idx4_op {
+	vstelmb_op = 0xc6, xvstelmh_op = 0xcd,
+};
+
+enum reg2i8idx5_op {
+	xvstelmb_op = 0x67,
+};
+
+enum reg2i9_op {
+	vldrepld_op = 0x602, xvldrepld_op = 0x642,
+};
+
+enum reg2i10_op {
+	vldreplw_op = 0x302, xvldreplw_op = 0x322,
+};
+
+enum reg2i11_op {
+	vldreplh_op = 0x182, xvldreplh_op = 0x192,
+};
+
+enum reg2i12_op {
+	slti_op = 0x8, sltui_op, addiw_op, addid_op,
+	lu52id_op, cacop_op = 0x18, xvldreplb_op = 0xca,
+	ldb_op = 0xa0, ldh_op, ldw_op, ldd_op, stb_op, sth_op,
+	stw_op, std_op, ldbu_op, ldhu_op, ldwu_op, preld_op,
+	flds_op, fsts_op, fldd_op, fstd_op, vld_op, vst_op, xvld_op,
+	xvst_op, ldlw_op = 0xb8, ldrw_op, ldld_op, ldrd_op, stlw_op,
+	strw_op, stld_op, strd_op, vldreplb_op = 0xc2,
+};
+
+enum reg2i14_op {
+	llw_op = 0x20, scw_op, lld_op, scd_op, ldptrw_op, stptrw_op,
+	ldptrd_op, stptrd_op,
+};
+
+enum reg2i16_op {
+	addu16id_op = 0x4, jirl_op = 0x13, beq_op = 0x16, bne_op, blt_op, bge_op, bltu_op, bgeu_op,
+};
+
+enum reg2csr_op {
+	csrrd_op = 0x4, csrwr_op = 0x4, csrxchg_op = 0x4,
+	gcsrrd_op = 0x5, gcsrwr_op = 0x5, gcsrxchg_op = 0x5,
+};
+
+enum reg3_op {
+	asrtled_op = 0x2, asrtgtd_op,
+	addw_op = 0x20, addd_op, subw_op, subd_op,
+	slt_op, sltu_op, maskeqz_op, masknez_op,
+	nor_op, and_op, or_op, xor_op, orn_op,
+	andn_op, sllw_op, srlw_op, sraw_op, slld_op,
+	srld_op, srad_op, rotrb_op, rotrh_op,
+	rotrw_op, rotrd_op, mulw_op, mulhw_op,
+	mulhwu_op, muld_op, mulhd_op, mulhdu_op,
+	mulwdw_op, mulwdwu_op, divw_op, modw_op,
+	divwu_op, modwu_op, divd_op, modd_op,
+	divdu_op, moddu_op, crcwbw_op,
+	crcwhw_op, crcwww_op, crcwdw_op, crccwbw_op,
+	crccwhw_op, crccwww_op, crccwdw_op, addu12iw_op,
+	addu12id_op,
+	adcb_op = 0x60, adch_op, adcw_op, adcd_op,
+	sbcb_op, sbch_op, sbcw_op, sbcd_op,
+	rcrb_op, rcrh_op, rcrw_op, rcrd_op,
+	ldxb_op = 0x7000, ldxh_op = 0x7008, ldxw_op = 0x7010, ldxd_op = 0x7018,
+	stxb_op = 0x7020, stxh_op = 0x7028, stxw_op = 0x7030, stxd_op = 0x7038,
+	ldxbu_op = 0x7040, ldxhu_op = 0x7048, ldxwu_op = 0x7050,
+	preldx_op = 0x7058, fldxs_op = 0x7060, fldxd_op = 0x7068,
+	fstxs_op = 0x7070, fstxd_op = 0x7078, vldx_op = 0x7080,
+	vstx_op = 0x7088, xvldx_op = 0x7090, xvstx_op = 0x7098,
+	amswapw_op = 0x70c0, amswapd_op, amaddw_op, amaddd_op, amandw_op,
+	amandd_op, amorw_op, amord_op, amxorw_op, amxord_op, ammaxw_op,
+	ammaxd_op, amminw_op, ammind_op, ammaxwu_op, ammaxdu_op,
+	amminwu_op, ammindu_op, amswap_dbw_op, amswap_dbd_op, amadd_dbw_op,
+	amadd_dbd_op, amand_dbw_op, amand_dbd_op, amor_dbw_op, amor_dbd_op,
+	amxor_dbw_op, amxor_dbd_op, ammax_dbw_op, ammax_dbd_op, ammin_dbw_op,
+	ammin_dbd_op, ammax_dbwu_op, ammax_dbdu_op, ammin_dbwu_op,
+	ammin_dbdu_op, fldgts_op = 0x70e8, fldgtd_op,
+	fldles_op, fldled_op, fstgts_op, fstgtd_op, fstles_op, fstled_op,
+	ldgtb_op, ldgth_op, ldgtw_op, ldgtd_op, ldleb_op, ldleh_op, ldlew_op,
+	ldled_op, stgtb_op, stgth_op, stgtw_op, stgtd_op, stleb_op, stleh_op,
+	stlew_op, stled_op,
+};
+
+enum reg3sa2_op {
+	alslw_op = 0x2, alslwu_op, bytepickw_op, alsld_op = 0x16,
+
+};
+
+enum reg3sa3_op {
+	bytepickd_op = 0x3,
+};
+
+struct reg2_format {
+	__BITFIELD_FIELD(unsigned int opcode : 22,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))
+};
+
+struct reg2ui3_format {
+	__BITFIELD_FIELD(unsigned int opcode : 19,
+	__BITFIELD_FIELD(unsigned int simmediate : 3,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2ui4_format {
+	__BITFIELD_FIELD(unsigned int opcode : 18,
+	__BITFIELD_FIELD(unsigned int simmediate : 4,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2ui5_format {
+	__BITFIELD_FIELD(unsigned int opcode : 17,
+	__BITFIELD_FIELD(unsigned int simmediate : 5,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2ui6_format {
+	__BITFIELD_FIELD(unsigned int opcode : 16,
+	__BITFIELD_FIELD(unsigned int simmediate : 6,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2lsbw_format {
+	__BITFIELD_FIELD(unsigned int opcode : 11,
+	__BITFIELD_FIELD(unsigned int msbw : 5,
+	__BITFIELD_FIELD(unsigned int op : 1,
+	__BITFIELD_FIELD(unsigned int lsbw : 5,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))))
+};
+
+struct reg2lsbd_format {
+	__BITFIELD_FIELD(unsigned int opcode : 10,
+	__BITFIELD_FIELD(unsigned int msbd : 6,
+	__BITFIELD_FIELD(unsigned int lsbd : 6,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg3_format {
+	__BITFIELD_FIELD(unsigned int opcode : 17,
+	__BITFIELD_FIELD(unsigned int rk : 5,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg3sa2_format {
+	__BITFIELD_FIELD(unsigned int opcode : 15,
+	__BITFIELD_FIELD(unsigned int simmediate : 2,
+	__BITFIELD_FIELD(unsigned int rk : 5,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg3sa3_format {
+	__BITFIELD_FIELD(unsigned int opcode : 14,
+	__BITFIELD_FIELD(unsigned int simmediate : 3,
+	__BITFIELD_FIELD(unsigned int rk : 5,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg3sa4_format {
+	__BITFIELD_FIELD(unsigned int opcode : 13,
+	__BITFIELD_FIELD(unsigned int simmediate : 4,
+	__BITFIELD_FIELD(unsigned int rk : 5,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg4_format {
+	__BITFIELD_FIELD(unsigned int opcode : 12,
+	__BITFIELD_FIELD(unsigned int fa : 5,
+	__BITFIELD_FIELD(unsigned int fk : 5,
+	__BITFIELD_FIELD(unsigned int fj : 5,
+	__BITFIELD_FIELD(unsigned int fd : 5,
+	;)))))
+};
+
+struct reg2i8_format {
+	__BITFIELD_FIELD(unsigned int opcode : 14,
+	__BITFIELD_FIELD(unsigned int simmediate : 8,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2i8idx1_format {
+	__BITFIELD_FIELD(unsigned int opcode : 13,
+	__BITFIELD_FIELD(unsigned int idx : 1,
+	__BITFIELD_FIELD(unsigned int simmediate : 8,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg2i8idx2_format {
+	__BITFIELD_FIELD(unsigned int opcode : 12,
+	__BITFIELD_FIELD(unsigned int idx : 2,
+	__BITFIELD_FIELD(unsigned int simmediate : 8,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg2i8idx3_format {
+	__BITFIELD_FIELD(unsigned int opcode : 11,
+	__BITFIELD_FIELD(unsigned int idx : 3,
+	__BITFIELD_FIELD(unsigned int simmediate : 8,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg2i8idx4_format {
+	__BITFIELD_FIELD(unsigned int opcode : 10,
+	__BITFIELD_FIELD(unsigned int idx : 4,
+	__BITFIELD_FIELD(unsigned int simmediate : 8,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg2i8idx5_format {
+	__BITFIELD_FIELD(unsigned int opcode : 9,
+	__BITFIELD_FIELD(unsigned int idx : 5,
+	__BITFIELD_FIELD(unsigned int simmediate : 8,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))))
+};
+
+struct reg2i9_format {
+	__BITFIELD_FIELD(unsigned int opcode : 13,
+	__BITFIELD_FIELD(unsigned int simmediate : 9,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2i10_format {
+	__BITFIELD_FIELD(unsigned int opcode : 12,
+	__BITFIELD_FIELD(unsigned int simmediate : 10,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2i11_format {
+	__BITFIELD_FIELD(unsigned int opcode : 11,
+	__BITFIELD_FIELD(unsigned int simmediate : 11,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2i12_format {
+	__BITFIELD_FIELD(unsigned int opcode : 10,
+	__BITFIELD_FIELD(signed int simmediate : 12,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2ui12_format {
+	__BITFIELD_FIELD(unsigned int opcode : 10,
+	__BITFIELD_FIELD(unsigned int simmediate : 12,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2i14_format {
+	__BITFIELD_FIELD(unsigned int opcode : 8,
+	__BITFIELD_FIELD(unsigned int simmediate : 14,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2i16_format {
+	__BITFIELD_FIELD(unsigned int opcode : 6,
+	__BITFIELD_FIELD(unsigned int simmediate : 16,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg2csr_format {
+	__BITFIELD_FIELD(unsigned int opcode : 8,
+	__BITFIELD_FIELD(unsigned int csr : 14,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;))))
+};
+
+struct reg1i21_format {
+	__BITFIELD_FIELD(unsigned int opcode : 6,
+	__BITFIELD_FIELD(unsigned int simmediate_l : 16,
+	__BITFIELD_FIELD(unsigned int rj : 5,
+	__BITFIELD_FIELD(unsigned int simmediate_h  : 5,
+	;))))
+};
+
+struct reg1i20_format {
+	__BITFIELD_FIELD(unsigned int opcode : 7,
+	__BITFIELD_FIELD(unsigned int simmediate : 20,
+	__BITFIELD_FIELD(unsigned int rd : 5,
+	;)))
+};
+
+struct reg0i15_format {
+	__BITFIELD_FIELD(unsigned int opcode : 17,
+	__BITFIELD_FIELD(unsigned int simmediate : 15,
+	;))
+};
+
+struct reg0i26_format {
+	__BITFIELD_FIELD(unsigned int opcode : 6,
+	__BITFIELD_FIELD(unsigned int simmediate_l : 16,
+	__BITFIELD_FIELD(unsigned int simmediate_h : 10,
+	;)))
+};
+
+union loongarch_instruction {
+	unsigned int word;
+	unsigned short halfword[2];
+	unsigned char byte[4];
+	struct reg2_format reg2_format;
+	struct reg2ui3_format reg2ui3_format;
+	struct reg2ui4_format reg2ui4_format;
+	struct reg2ui5_format reg2ui5_format;
+	struct reg2ui6_format reg2ui6_format;
+	struct reg2ui12_format reg2ui12_format;
+	struct reg2lsbw_format reg2lsbw_format;
+	struct reg2lsbd_format reg2lsbd_format;
+	struct reg3_format reg3_format;
+	struct reg3sa2_format reg3sa2_format;
+	struct reg3sa3_format reg3sa3_format;
+	struct reg3sa4_format reg3sa4_format;
+	struct reg4_format reg4_format;
+	struct reg2i8_format reg2i8_format;
+	struct reg2i8idx1_format reg2i8idx1_format;
+	struct reg2i8idx2_format reg2i8idx2_format;
+	struct reg2i8idx3_format reg2i8idx3_format;
+	struct reg2i8idx4_format reg2i8idx4_format;
+	struct reg2i8idx5_format reg2i8idx5_format;
+	struct reg2i9_format reg2i9_format;
+	struct reg2i10_format reg2i10_format;
+	struct reg2i11_format reg2i11_format;
+	struct reg2i12_format reg2i12_format;
+	struct reg2i14_format reg2i14_format;
+	struct reg2i16_format reg2i16_format;
+	struct reg2csr_format reg2csr_format;
+	struct reg1i21_format reg1i21_format;
+	struct reg1i20_format reg1i20_format;
+	struct reg0i15_format reg0i15_format;
+	struct reg0i26_format reg0i26_format;
+};
+
+#endif /* _UAPI_ASM_INST_H */
-- 
2.33.0

