From bde1694aecdb535970787b4f1d07ddb317e191e3 Mon Sep 17 00:00:00 2001
From: Namjae Jeon <namjae.jeon@samsung.com>
Date: Mon, 28 Jun 2021 15:23:19 +0900
Subject: [PATCH] ksmbd: remove ksmbd_err/info
Git-commit: bde1694aecdb535970787b4f1d07ddb317e191e3
Patch-mainline: v5.15-rc1
References: bsn#12
Modified-by-SEL: No


Use the pr_fmt built into pr_*. and use pr_err/info after removing
wrapper ksmbd_err/info.

Reviewed-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Namjae Jeon <namjae.jeon@samsung.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 fs/cifsd/auth.c              |  18 ++--
 fs/cifsd/connection.c        |  15 ++-
 fs/cifsd/crypto_ctx.c        |   4 +-
 fs/cifsd/glob.h              |  24 ++---
 fs/cifsd/mgmt/user_session.c |   4 +-
 fs/cifsd/misc.c              |   2 +-
 fs/cifsd/ndr.c               |  14 +--
 fs/cifsd/oplock.c            |  20 ++--
 fs/cifsd/server.c            |   6 +-
 fs/cifsd/smb2misc.c          |   8 +-
 fs/cifsd/smb2pdu.c           | 204 +++++++++++++++++------------------
 fs/cifsd/smb_common.c        |   2 +-
 fs/cifsd/smbacl.c            |  26 ++---
 fs/cifsd/transport_ipc.c     |  30 +++---
 fs/cifsd/transport_rdma.c    | 106 +++++++++---------
 fs/cifsd/transport_tcp.c     |  20 ++--
 fs/cifsd/vfs.c               |  88 +++++++--------
 fs/cifsd/vfs_cache.c         |  10 +-
 18 files changed, 294 insertions(+), 307 deletions(-)

diff --git a/fs/cifsd/auth.c b/fs/cifsd/auth.c
index daf31c9f0880..de36f12070bf 100644
--- a/fs/cifsd/auth.c
+++ b/fs/cifsd/auth.c
@@ -342,7 +342,7 @@ int ksmbd_auth_ntlm(struct ksmbd_session *sess, char *pw_buf)
 	memcpy(p21, user_passkey(sess->user), CIFS_NTHASH_SIZE);
 	rc = ksmbd_enc_p24(p21, sess->ntlmssp.cryptkey, key);
 	if (rc) {
-		ksmbd_err("password processing failed\n");
+		pr_err("password processing failed\n");
 		return rc;
 	}
 
@@ -461,7 +461,7 @@ static int __ksmbd_auth_ntlmv2(struct ksmbd_session *sess, char *client_nonce,
 				       client_nonce,
 				       (char *)sess->ntlmssp.cryptkey, 8);
 	if (rc) {
-		ksmbd_err("password processing failed\n");
+		pr_err("password processing failed\n");
 		goto out;
 	}
 
@@ -469,7 +469,7 @@ static int __ksmbd_auth_ntlmv2(struct ksmbd_session *sess, char *client_nonce,
 	memcpy(p21, user_passkey(sess->user), CIFS_NTHASH_SIZE);
 	rc = ksmbd_enc_p24(p21, sess_key, key);
 	if (rc) {
-		ksmbd_err("password processing failed\n");
+		pr_err("password processing failed\n");
 		goto out;
 	}
 
@@ -1269,7 +1269,7 @@ int ksmbd_crypt_message(struct ksmbd_conn *conn, struct kvec *iov,
 				      enc,
 				      key);
 	if (rc) {
-		ksmbd_err("Could not get %scryption key\n", enc ? "en" : "de");
+		pr_err("Could not get %scryption key\n", enc ? "en" : "de");
 		return rc;
 	}
 
@@ -1279,7 +1279,7 @@ int ksmbd_crypt_message(struct ksmbd_conn *conn, struct kvec *iov,
 	else
 		ctx = ksmbd_crypto_ctx_find_ccm();
 	if (!ctx) {
-		ksmbd_err("crypto alloc failed\n");
+		pr_err("crypto alloc failed\n");
 		return -ENOMEM;
 	}
 
@@ -1295,19 +1295,18 @@ int ksmbd_crypt_message(struct ksmbd_conn *conn, struct kvec *iov,
 	else
 		rc = crypto_aead_setkey(tfm, key, SMB3_GCM128_CRYPTKEY_SIZE);
 	if (rc) {
-		ksmbd_err("Failed to set aead key %d\n", rc);
+		pr_err("Failed to set aead key %d\n", rc);
 		goto free_ctx;
 	}
 
 	rc = crypto_aead_setauthsize(tfm, SMB2_SIGNATURE_SIZE);
 	if (rc) {
-		ksmbd_err("Failed to set authsize %d\n", rc);
+		pr_err("Failed to set authsize %d\n", rc);
 		goto free_ctx;
 	}
 
 	req = aead_request_alloc(tfm, GFP_KERNEL);
 	if (!req) {
-		ksmbd_err("Failed to alloc aead request\n");
 		rc = -ENOMEM;
 		goto free_ctx;
 	}
@@ -1319,7 +1318,7 @@ int ksmbd_crypt_message(struct ksmbd_conn *conn, struct kvec *iov,
 
 	sg = ksmbd_init_sg(iov, nvec, sign);
 	if (!sg) {
-		ksmbd_err("Failed to init sg\n");
+		pr_err("Failed to init sg\n");
 		rc = -ENOMEM;
 		goto free_req;
 	}
@@ -1327,7 +1326,6 @@ int ksmbd_crypt_message(struct ksmbd_conn *conn, struct kvec *iov,
 	iv_len = crypto_aead_ivsize(tfm);
 	iv = kzalloc(iv_len, GFP_KERNEL);
 	if (!iv) {
-		ksmbd_err("Failed to alloc IV\n");
 		rc = -ENOMEM;
 		goto free_sg;
 	}
diff --git a/fs/cifsd/connection.c b/fs/cifsd/connection.c
index a0d15093dd6f..928e22e19def 100644
--- a/fs/cifsd/connection.c
+++ b/fs/cifsd/connection.c
@@ -160,7 +160,7 @@ int ksmbd_conn_write(struct ksmbd_work *work)
 
 	ksmbd_conn_try_dequeue_request(work);
 	if (!rsp_hdr) {
-		ksmbd_err("NULL response header\n");
+		pr_err("NULL response header\n");
 		return -EINVAL;
 	}
 
@@ -192,7 +192,7 @@ int ksmbd_conn_write(struct ksmbd_work *work)
 	ksmbd_conn_unlock(conn);
 
 	if (sent < 0) {
-		ksmbd_err("Failed to send message: %d\n", sent);
+		pr_err("Failed to send message: %d\n", sent);
 		return sent;
 	}
 
@@ -315,24 +315,23 @@ int ksmbd_conn_handler_loop(void *p)
 		 */
 		size = t->ops->read(t, conn->request_buf + 4, pdu_size);
 		if (size < 0) {
-			ksmbd_err("sock_read failed: %d\n", size);
+			pr_err("sock_read failed: %d\n", size);
 			break;
 		}
 
 		if (size != pdu_size) {
-			ksmbd_err("PDU error. Read: %d, Expected: %d\n",
-				  size,
-				  pdu_size);
+			pr_err("PDU error. Read: %d, Expected: %d\n",
+			       size, pdu_size);
 			continue;
 		}
 
 		if (!default_conn_ops.process_fn) {
-			ksmbd_err("No connection request callback\n");
+			pr_err("No connection request callback\n");
 			break;
 		}
 
 		if (default_conn_ops.process_fn(conn)) {
-			ksmbd_err("Cannot handle request\n");
+			pr_err("Cannot handle request\n");
 			break;
 		}
 	}
diff --git a/fs/cifsd/crypto_ctx.c b/fs/cifsd/crypto_ctx.c
index 7b727fe141a6..5f4b1008d17e 100644
--- a/fs/cifsd/crypto_ctx.c
+++ b/fs/cifsd/crypto_ctx.c
@@ -48,12 +48,12 @@ static struct crypto_aead *alloc_aead(int id)
 		tfm = crypto_alloc_aead("ccm(aes)", 0, 0);
 		break;
 	default:
-		ksmbd_err("Does not support encrypt ahead(id : %d)\n", id);
+		pr_err("Does not support encrypt ahead(id : %d)\n", id);
 		return NULL;
 	}
 
 	if (IS_ERR(tfm)) {
-		ksmbd_err("Failed to alloc encrypt aead : %ld\n", PTR_ERR(tfm));
+		pr_err("Failed to alloc encrypt aead : %ld\n", PTR_ERR(tfm));
 		return NULL;
 	}
 
diff --git a/fs/cifsd/glob.h b/fs/cifsd/glob.h
index da8f804a3ee2..8119cb7ddbed 100644
--- a/fs/cifsd/glob.h
+++ b/fs/cifsd/glob.h
@@ -31,32 +31,22 @@ extern int ksmbd_debug_types;
 				KSMBD_DEBUG_IPC | KSMBD_DEBUG_CONN |	\
 				KSMBD_DEBUG_RDMA)
 
-#ifndef ksmbd_pr_fmt
+#ifdef pr_fmt
+#undef pr_fmt
+#endif
+
 #ifdef SUBMOD_NAME
-#define ksmbd_pr_fmt(fmt)	"ksmbd: " SUBMOD_NAME ": " fmt
+#define pr_fmt(fmt)	"ksmbd: " SUBMOD_NAME ": " fmt
 #else
-#define ksmbd_pr_fmt(fmt)	"ksmbd: " fmt
-#endif
+#define pr_fmt(fmt)	"ksmbd: " fmt
 #endif
 
 #define ksmbd_debug(type, fmt, ...)				\
 	do {							\
 		if (ksmbd_debug_types & KSMBD_DEBUG_##type)	\
-			pr_info(ksmbd_pr_fmt("%s:%d: " fmt),	\
-				__func__,			\
-				__LINE__,			\
-				##__VA_ARGS__);			\
+			pr_info(fmt, ##__VA_ARGS__);		\
 	} while (0)
 
-#define ksmbd_info(fmt, ...)					\
-			pr_info(ksmbd_pr_fmt(fmt), ##__VA_ARGS__)
-
-#define ksmbd_err(fmt, ...)					\
-			pr_err(ksmbd_pr_fmt("%s:%d: " fmt),	\
-				__func__,			\
-				__LINE__,			\
-				##__VA_ARGS__)
-
 #define UNICODE_LEN(x)		((x) * 2)
 
 #endif /* __KSMBD_GLOB_H */
diff --git a/fs/cifsd/mgmt/user_session.c b/fs/cifsd/mgmt/user_session.c
index 77bdf3642f72..615b46f0762b 100644
--- a/fs/cifsd/mgmt/user_session.c
+++ b/fs/cifsd/mgmt/user_session.c
@@ -87,7 +87,7 @@ static int __rpc_method(char *rpc_name)
 	if (!strcmp(rpc_name, "\\lsarpc") || !strcmp(rpc_name, "lsarpc"))
 		return KSMBD_RPC_LSARPC_METHOD_INVOKE;
 
-	ksmbd_err("Unsupported RPC: %s\n", rpc_name);
+	pr_err("Unsupported RPC: %s\n", rpc_name);
 	return 0;
 }
 
@@ -232,7 +232,7 @@ int get_session(struct ksmbd_session *sess)
 void put_session(struct ksmbd_session *sess)
 {
 	if (atomic_dec_and_test(&sess->refcnt))
-		ksmbd_err("get/%s seems to be mismatched.", __func__);
+		pr_err("get/%s seems to be mismatched.", __func__);
 }
 
 struct ksmbd_session *ksmbd_session_lookup_slowpath(unsigned long long id)
diff --git a/fs/cifsd/misc.c b/fs/cifsd/misc.c
index 1c6ed20f4a18..0b307ca28a19 100644
--- a/fs/cifsd/misc.c
+++ b/fs/cifsd/misc.c
@@ -107,7 +107,7 @@ static int ksmbd_validate_stream_name(char *stream_name)
 
 		stream_name++;
 		if (c == '/' || c == ':' || c == '\\') {
-			ksmbd_err("Stream name validation failed: %c\n", c);
+			pr_err("Stream name validation failed: %c\n", c);
 			return -ENOENT;
 		}
 	}
diff --git a/fs/cifsd/ndr.c b/fs/cifsd/ndr.c
index 14189832c65e..46cc01475d38 100644
--- a/fs/cifsd/ndr.c
+++ b/fs/cifsd/ndr.c
@@ -178,14 +178,14 @@ int ndr_decode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da)
 	da->version = ndr_read_int16(n);
 
 	if (da->version != 3 && da->version != 4) {
-		ksmbd_err("v%d version is not supported\n", da->version);
+		pr_err("v%d version is not supported\n", da->version);
 		return -EINVAL;
 	}
 
 	version2 = ndr_read_int32(n);
 	if (da->version != version2) {
-		ksmbd_err("ndr version mismatched(version: %d, version2: %d)\n",
-			  da->version, version2);
+		pr_err("ndr version mismatched(version: %d, version2: %d)\n",
+		       da->version, version2);
 		return -EINVAL;
 	}
 
@@ -309,14 +309,14 @@ int ndr_decode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl)
 	n->offset = 0;
 	acl->version = ndr_read_int16(n);
 	if (acl->version != 4) {
-		ksmbd_err("v%d version is not supported\n", acl->version);
+		pr_err("v%d version is not supported\n", acl->version);
 		return -EINVAL;
 	}
 
 	version2 = ndr_read_int32(n);
 	if (acl->version != version2) {
-		ksmbd_err("ndr version mismatched(version: %d, version2: %d)\n",
-			  acl->version, version2);
+		pr_err("ndr version mismatched(version: %d, version2: %d)\n",
+		       acl->version, version2);
 		return -EINVAL;
 	}
 
@@ -329,7 +329,7 @@ int ndr_decode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl)
 
 	ndr_read_bytes(n, acl->desc, 10);
 	if (strncmp(acl->desc, "posix_acl", 9)) {
-		ksmbd_err("Invalid acl description : %s\n", acl->desc);
+		pr_err("Invalid acl description : %s\n", acl->desc);
 		return -EINVAL;
 	}
 
diff --git a/fs/cifsd/oplock.c b/fs/cifsd/oplock.c
index 1ef2acbea2bb..9027cb7d970f 100644
--- a/fs/cifsd/oplock.c
+++ b/fs/cifsd/oplock.c
@@ -230,9 +230,9 @@ int opinfo_write_to_read(struct oplock_info *opinfo)
 
 	if (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||
 	      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {
-		ksmbd_err("bad oplock(0x%x)\n", opinfo->level);
+		pr_err("bad oplock(0x%x)\n", opinfo->level);
 		if (opinfo->is_lease)
-			ksmbd_err("lease state(0x%x)\n", lease->state);
+			pr_err("lease state(0x%x)\n", lease->state);
 		return -EINVAL;
 	}
 	opinfo->level = SMB2_OPLOCK_LEVEL_II;
@@ -269,9 +269,9 @@ int opinfo_write_to_none(struct oplock_info *opinfo)
 
 	if (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||
 	      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {
-		ksmbd_err("bad oplock(0x%x)\n", opinfo->level);
+		pr_err("bad oplock(0x%x)\n", opinfo->level);
 		if (opinfo->is_lease)
-			ksmbd_err("lease state(0x%x)\n", lease->state);
+			pr_err("lease state(0x%x)\n", lease->state);
 		return -EINVAL;
 	}
 	opinfo->level = SMB2_OPLOCK_LEVEL_NONE;
@@ -291,9 +291,9 @@ int opinfo_read_to_none(struct oplock_info *opinfo)
 	struct lease *lease = opinfo->o_lease;
 
 	if (opinfo->level != SMB2_OPLOCK_LEVEL_II) {
-		ksmbd_err("bad oplock(0x%x)\n", opinfo->level);
+		pr_err("bad oplock(0x%x)\n", opinfo->level);
 		if (opinfo->is_lease)
-			ksmbd_err("lease state(0x%x)\n", lease->state);
+			pr_err("lease state(0x%x)\n", lease->state);
 		return -EINVAL;
 	}
 	opinfo->level = SMB2_OPLOCK_LEVEL_NONE;
@@ -622,7 +622,7 @@ static void __smb2_oplock_break_noti(struct work_struct *wk)
 	}
 
 	if (allocate_oplock_break_buf(work)) {
-		ksmbd_err("smb2_allocate_rsp_buf failed! ");
+		pr_err("smb2_allocate_rsp_buf failed! ");
 		atomic_dec(&conn->r_count);
 		ksmbd_fd_put(work, fp);
 		ksmbd_free_work_struct(work);
@@ -1680,18 +1680,18 @@ int smb2_check_durable_oplock(struct ksmbd_file *fp,
 
 	if (opinfo && opinfo->is_lease) {
 		if (!lctx) {
-			ksmbd_err("open does not include lease\n");
+			pr_err("open does not include lease\n");
 			ret = -EBADF;
 			goto out;
 		}
 		if (memcmp(opinfo->o_lease->lease_key, lctx->lease_key,
 			   SMB2_LEASE_KEY_SIZE)) {
-			ksmbd_err("invalid lease key\n");
+			pr_err("invalid lease key\n");
 			ret = -EBADF;
 			goto out;
 		}
 		if (name && strcmp(fp->filename, name)) {
-			ksmbd_err("invalid name reconnect %s\n", name);
+			pr_err("invalid name reconnect %s\n", name);
 			ret = -EINVAL;
 			goto out;
 		}
diff --git a/fs/cifsd/server.c b/fs/cifsd/server.c
index 6d14daae1b07..a8c59e96a2f7 100644
--- a/fs/cifsd/server.c
+++ b/fs/cifsd/server.c
@@ -277,7 +277,7 @@ static int queue_ksmbd_work(struct ksmbd_conn *conn)
 
 	work = ksmbd_alloc_work_struct();
 	if (!work) {
-		ksmbd_err("allocation for work failed\n");
+		pr_err("allocation for work failed\n");
 		return -ENOMEM;
 	}
 
@@ -442,7 +442,7 @@ static ssize_t kill_server_store(struct class *class,
 	if (!sysfs_streq(buf, "hard"))
 		return len;
 
-	ksmbd_info("kill command received\n");
+	pr_info("kill command received\n");
 	mutex_lock(&ctrl_lock);
 	WRITE_ONCE(server_conf.state, SERVER_STATE_RESETTING);
 	__module_get(THIS_MODULE);
@@ -547,7 +547,7 @@ static int __init ksmbd_server_init(void)
 
 	ret = class_register(&ksmbd_control_class);
 	if (ret) {
-		ksmbd_err("Unable to register ksmbd-control class\n");
+		pr_err("Unable to register ksmbd-control class\n");
 		return ret;
 	}
 
diff --git a/fs/cifsd/smb2misc.c b/fs/cifsd/smb2misc.c
index c4b870dbf683..e412d69690ed 100644
--- a/fs/cifsd/smb2misc.c
+++ b/fs/cifsd/smb2misc.c
@@ -320,12 +320,12 @@ static int smb2_validate_credit_charge(struct smb2_hdr *hdr)
 	max_len = max(req_len, expect_resp_len);
 	calc_credit_num = DIV_ROUND_UP(max_len, SMB2_MAX_BUFFER_SIZE);
 	if (!credit_charge && max_len > SMB2_MAX_BUFFER_SIZE) {
-		ksmbd_err("credit charge is zero and payload size(%d) is bigger than 64K\n",
-			  max_len);
+		pr_err("credit charge is zero and payload size(%d) is bigger than 64K\n",
+		       max_len);
 		return 1;
 	} else if (credit_charge < calc_credit_num) {
-		ksmbd_err("credit charge : %d, calc_credit_num : %d\n",
-			  credit_charge, calc_credit_num);
+		pr_err("credit charge : %d, calc_credit_num : %d\n",
+		       credit_charge, calc_credit_num);
 		return 1;
 	}
 
diff --git a/fs/cifsd/smb2pdu.c b/fs/cifsd/smb2pdu.c
index f1642fffe4e1..84f4cd7f545f 100644
--- a/fs/cifsd/smb2pdu.c
+++ b/fs/cifsd/smb2pdu.c
@@ -66,7 +66,7 @@ static inline int check_session_id(struct ksmbd_conn *conn, u64 id)
 	sess = ksmbd_session_lookup_all(conn, id);
 	if (sess)
 		return 1;
-	ksmbd_err("Invalid user session id: %llu\n", id);
+	pr_err("Invalid user session id: %llu\n", id);
 	return 0;
 }
 
@@ -109,7 +109,7 @@ int smb2_get_ksmbd_tcon(struct ksmbd_work *work)
 	tree_id = le32_to_cpu(req_hdr->Id.SyncId.TreeId);
 	work->tcon = ksmbd_tree_conn_lookup(work->sess, tree_id);
 	if (!work->tcon) {
-		ksmbd_err("Invalid tid %d\n", tree_id);
+		pr_err("Invalid tid %d\n", tree_id);
 		return -1;
 	}
 
@@ -329,7 +329,7 @@ int smb2_set_rsp_credits(struct ksmbd_work *work)
 	min_credits = conn->max_credits >> 4;
 
 	if (conn->total_credits >= conn->max_credits) {
-		ksmbd_err("Total credits overflow: %d\n", conn->total_credits);
+		pr_err("Total credits overflow: %d\n", conn->total_credits);
 		conn->total_credits = min_credits;
 	}
 
@@ -634,7 +634,7 @@ smb2_get_name(struct ksmbd_share_config *share, const char *src,
 
 	name = smb_strndup_from_utf16(src, maxlen, 1, local_nls);
 	if (IS_ERR(name)) {
-		ksmbd_err("failed to get name %ld\n", PTR_ERR(name));
+		pr_err("failed to get name %ld\n", PTR_ERR(name));
 		return name;
 	}
 
@@ -645,7 +645,7 @@ smb2_get_name(struct ksmbd_share_config *share, const char *src,
 	unixname = convert_to_unix_name(share, name);
 	kfree(name);
 	if (!unixname) {
-		ksmbd_err("can not convert absolute name\n");
+		pr_err("can not convert absolute name\n");
 		return ERR_PTR(-ENOMEM);
 	}
 
@@ -664,7 +664,7 @@ int setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)
 
 	id = ksmbd_acquire_async_msg_id(&conn->async_ida);
 	if (id < 0) {
-		ksmbd_err("Failed to alloc async message id\n");
+		pr_err("Failed to alloc async message id\n");
 		return id;
 	}
 	work->syncronous = false;
@@ -1005,13 +1005,13 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 	ksmbd_debug(SMB, "Received negotiate request\n");
 	conn->need_neg = false;
 	if (ksmbd_conn_good(work)) {
-		ksmbd_err("conn->tcp_status is already in CifsGood State\n");
+		pr_err("conn->tcp_status is already in CifsGood State\n");
 		work->send_no_response = 1;
 		return rc;
 	}
 
 	if (req->DialectCount == 0) {
-		ksmbd_err("malformed packet\n");
+		pr_err("malformed packet\n");
 		rsp->hdr.Status = STATUS_INVALID_PARAMETER;
 		rc = -EINVAL;
 		goto err_out;
@@ -1031,8 +1031,8 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 
 		status = deassemble_neg_contexts(conn, req);
 		if (status != STATUS_SUCCESS) {
-			ksmbd_err("deassemble_neg_contexts error(0x%x)\n",
-				  status);
+			pr_err("deassemble_neg_contexts error(0x%x)\n",
+			       status);
 			rsp->hdr.Status = status;
 			rc = -EINVAL;
 			goto err_out;
@@ -1293,7 +1293,7 @@ static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
 				      true,
 				      conn->local_nls);
 	if (IS_ERR(name)) {
-		ksmbd_err("cannot allocate memory\n");
+		pr_err("cannot allocate memory\n");
 		return NULL;
 	}
 
@@ -1438,7 +1438,7 @@ static int ntlm_authenticate(struct ksmbd_work *work)
 
 	if (conn->dialect > SMB20_PROT_ID) {
 		if (!ksmbd_conn_lookup_dialect(conn)) {
-			ksmbd_err("fail to verify the dialect\n");
+			pr_err("fail to verify the dialect\n");
 			rsp->hdr.Status = STATUS_USER_SESSION_DELETED;
 			return -EPERM;
 		}
@@ -1528,7 +1528,7 @@ static int krb5_authenticate(struct ksmbd_work *work)
 
 	if (conn->dialect > SMB20_PROT_ID) {
 		if (!ksmbd_conn_lookup_dialect(conn)) {
-			ksmbd_err("fail to verify the dialect\n");
+			pr_err("fail to verify the dialect\n");
 			rsp->hdr.Status = STATUS_USER_SESSION_DELETED;
 			return -EPERM;
 		}
@@ -1688,11 +1688,11 @@ int smb2_sess_setup(struct ksmbd_work *work)
 			}
 		} else {
 			/* TODO: need one more negotiation */
-			ksmbd_err("Not support the preferred authentication\n");
+			pr_err("Not support the preferred authentication\n");
 			rc = -EINVAL;
 		}
 	} else {
-		ksmbd_err("Not support authentication\n");
+		pr_err("Not support authentication\n");
 		rc = -EINVAL;
 	}
 
@@ -1742,7 +1742,7 @@ int smb2_tree_connect(struct ksmbd_work *work)
 					  le16_to_cpu(req->PathLength), true,
 					  conn->local_nls);
 	if (IS_ERR(treename)) {
-		ksmbd_err("treename is NULL\n");
+		pr_err("treename is NULL\n");
 		status.ret = KSMBD_TREE_CONN_STATUS_ERROR;
 		goto out_err1;
 	}
@@ -1986,7 +1986,7 @@ static noinline int create_smb2_pipe(struct ksmbd_work *work)
 
 	id = ksmbd_session_rpc_open(work->sess, name);
 	if (id < 0) {
-		ksmbd_err("Unable to open RPC pipe: %d\n", id);
+		pr_err("Unable to open RPC pipe: %d\n", id);
 		err = id;
 		goto out;
 	}
@@ -2120,7 +2120,7 @@ static inline int check_context_err(void *ctx, char *str)
 	ksmbd_debug(SMB, "find context %s err %d\n", str, err);
 
 	if (err == -EINVAL) {
-		ksmbd_err("bad name length\n");
+		pr_err("bad name length\n");
 		return err;
 	}
 
@@ -2159,7 +2159,7 @@ static noinline int smb2_set_stream_name_xattr(struct path *path,
 
 	rc = ksmbd_vfs_setxattr(path->dentry, xattr_stream_name, NULL, 0, 0);
 	if (rc < 0)
-		ksmbd_err("Failed to store XATTR stream name :%d\n", rc);
+		pr_err("Failed to store XATTR stream name :%d\n", rc);
 	return 0;
 }
 
@@ -2201,7 +2201,7 @@ static int smb2_create_truncate(struct path *path)
 	int rc = vfs_truncate(path, 0);
 
 	if (rc) {
-		ksmbd_err("vfs_truncate failed, rc %d\n", rc);
+		pr_err("vfs_truncate failed, rc %d\n", rc);
 		return rc;
 	}
 
@@ -2287,8 +2287,8 @@ static int smb2_creat(struct ksmbd_work *work, struct path *path, char *name,
 
 	rc = ksmbd_vfs_kern_path(name, 0, path, 0);
 	if (rc) {
-		ksmbd_err("cannot get linux path (%s), err = %d\n",
-			  name, rc);
+		pr_err("cannot get linux path (%s), err = %d\n",
+		       name, rc);
 		return rc;
 	}
 	return 0;
@@ -2387,7 +2387,7 @@ int smb2_open(struct ksmbd_work *work)
 	if (req->NameLength) {
 		if ((req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&
 		    *(char *)req->Buffer == '\\') {
-			ksmbd_err("not allow directory name included leading slash\n");
+			pr_err("not allow directory name included leading slash\n");
 			rc = -EINVAL;
 			goto err_out1;
 		}
@@ -2444,16 +2444,16 @@ int smb2_open(struct ksmbd_work *work)
 		lc = parse_lease_state(req);
 
 	if (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE_LE)) {
-		ksmbd_err("Invalid impersonationlevel : 0x%x\n",
-			  le32_to_cpu(req->ImpersonationLevel));
+		pr_err("Invalid impersonationlevel : 0x%x\n",
+		       le32_to_cpu(req->ImpersonationLevel));
 		rc = -EIO;
 		rsp->hdr.Status = STATUS_BAD_IMPERSONATION_LEVEL;
 		goto err_out1;
 	}
 
 	if (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK)) {
-		ksmbd_err("Invalid create options : 0x%x\n",
-			  le32_to_cpu(req->CreateOptions));
+		pr_err("Invalid create options : 0x%x\n",
+		       le32_to_cpu(req->CreateOptions));
 		rc = -EINVAL;
 		goto err_out1;
 	} else {
@@ -2480,22 +2480,22 @@ int smb2_open(struct ksmbd_work *work)
 
 	if (le32_to_cpu(req->CreateDisposition) >
 	    le32_to_cpu(FILE_OVERWRITE_IF_LE)) {
-		ksmbd_err("Invalid create disposition : 0x%x\n",
-			  le32_to_cpu(req->CreateDisposition));
+		pr_err("Invalid create disposition : 0x%x\n",
+		       le32_to_cpu(req->CreateDisposition));
 		rc = -EINVAL;
 		goto err_out1;
 	}
 
 	if (!(req->DesiredAccess & DESIRED_ACCESS_MASK)) {
-		ksmbd_err("Invalid desired access : 0x%x\n",
-			  le32_to_cpu(req->DesiredAccess));
+		pr_err("Invalid desired access : 0x%x\n",
+		       le32_to_cpu(req->DesiredAccess));
 		rc = -EACCES;
 		goto err_out1;
 	}
 
 	if (req->FileAttributes && !(req->FileAttributes & ATTR_MASK_LE)) {
-		ksmbd_err("Invalid file attribute : 0x%x\n",
-			  le32_to_cpu(req->FileAttributes));
+		pr_err("Invalid file attribute : 0x%x\n",
+		       le32_to_cpu(req->FileAttributes));
 		rc = -EINVAL;
 		goto err_out1;
 	}
@@ -2750,7 +2750,7 @@ int smb2_open(struct ksmbd_work *work)
 	filp = dentry_open(&path, open_flags, current_cred());
 	if (IS_ERR(filp)) {
 		rc = PTR_ERR(filp);
-		ksmbd_err("dentry open for dir failed, rc %d\n", rc);
+		pr_err("dentry open for dir failed, rc %d\n", rc);
 		goto err_out;
 	}
 
@@ -2846,8 +2846,8 @@ int smb2_open(struct ksmbd_work *work)
 								    pntsd_size);
 					kfree(pntsd);
 					if (rc)
-						ksmbd_err("failed to store ntacl in xattr : %d\n",
-							  rc);
+						pr_err("failed to store ntacl in xattr : %d\n",
+						       rc);
 				}
 			}
 		}
@@ -3697,14 +3697,14 @@ int smb2_query_dir(struct ksmbd_work *work)
 	if (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||
 	    inode_permission(&init_user_ns, file_inode(dir_fp->filp),
 			     MAY_READ | MAY_EXEC)) {
-		ksmbd_err("no right to enumerate directory (%s)\n",
-			  FP_FILENAME(dir_fp));
+		pr_err("no right to enumerate directory (%s)\n",
+		       FP_FILENAME(dir_fp));
 		rc = -EACCES;
 		goto err_out2;
 	}
 
 	if (!S_ISDIR(file_inode(dir_fp->filp)->i_mode)) {
-		ksmbd_err("can't do query dir for a file\n");
+		pr_err("can't do query dir for a file\n");
 		rc = -EINVAL;
 		goto err_out2;
 	}
@@ -3805,7 +3805,7 @@ int smb2_query_dir(struct ksmbd_work *work)
 	return 0;
 
 err_out:
-	ksmbd_err("error while processing smb2 query dir rc = %d\n", rc);
+	pr_err("error while processing smb2 query dir rc = %d\n", rc);
 	kfree(srch_ptr);
 
 err_out2:
@@ -3843,7 +3843,7 @@ static int buffer_check_err(int reqOutputBufferLength,
 {
 	if (reqOutputBufferLength < le32_to_cpu(rsp->OutputBufferLength)) {
 		if (reqOutputBufferLength < infoclass_size) {
-			ksmbd_err("Invalid Buffer Size Requested\n");
+			pr_err("Invalid Buffer Size Requested\n");
 			rsp->hdr.Status = STATUS_INFO_LENGTH_MISMATCH;
 			rsp->hdr.smb2_buf_length = cpu_to_be32(sizeof(struct smb2_hdr) - 4);
 			return -EINVAL;
@@ -3946,8 +3946,8 @@ static int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,
 	struct path *path;
 
 	if (!(fp->daccess & FILE_READ_EA_LE)) {
-		ksmbd_err("Not permitted to read ext attr : 0x%x\n",
-			  fp->daccess);
+		pr_err("Not permitted to read ext attr : 0x%x\n",
+		       fp->daccess);
 		return -EACCES;
 	}
 
@@ -4103,8 +4103,8 @@ static int get_file_basic_info(struct smb2_query_info_rsp *rsp,
 	u64 time;
 
 	if (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {
-		ksmbd_err("no right to read the attributes : 0x%x\n",
-			  fp->daccess);
+		pr_err("no right to read the attributes : 0x%x\n",
+		       fp->daccess);
 		return -EACCES;
 	}
 
@@ -4375,8 +4375,8 @@ static int get_file_network_open_info(struct smb2_query_info_rsp *rsp,
 	u64 time;
 
 	if (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {
-		ksmbd_err("no right to read the attributes : 0x%x\n",
-			  fp->daccess);
+		pr_err("no right to read the attributes : 0x%x\n",
+		       fp->daccess);
 		return -EACCES;
 	}
 
@@ -4465,8 +4465,8 @@ static int get_file_attribute_tag_info(struct smb2_query_info_rsp *rsp,
 	struct smb2_file_attr_tag_info *file_info;
 
 	if (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {
-		ksmbd_err("no right to read the attributes : 0x%x\n",
-			  fp->daccess);
+		pr_err("no right to read the attributes : 0x%x\n",
+		       fp->daccess);
 		return -EACCES;
 	}
 
@@ -4620,7 +4620,7 @@ static int smb2_get_info_file(struct ksmbd_work *work,
 		break;
 	case SMB_FIND_FILE_POSIX_INFO:
 		if (!work->tcon->posix_extensions) {
-			ksmbd_err("client doesn't negotiate with SMB3.1.1 POSIX Extensions\n");
+			pr_err("client doesn't negotiate with SMB3.1.1 POSIX Extensions\n");
 			rc = -EOPNOTSUPP;
 		} else {
 			rc = find_file_posix_info(rsp, fp, rsp_org);
@@ -4659,13 +4659,13 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 
 	rc = ksmbd_vfs_kern_path(share->path, lookup_flags, &path, 0);
 	if (rc) {
-		ksmbd_err("cannot create vfs path\n");
+		pr_err("cannot create vfs path\n");
 		return -EIO;
 	}
 
 	rc = vfs_statfs(&path, &stfs);
 	if (rc) {
-		ksmbd_err("cannot do stat of path %s\n", share->path);
+		pr_err("cannot do stat of path %s\n", share->path);
 		path_put(&path);
 		return -EIO;
 	}
@@ -4846,7 +4846,7 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		unsigned short logical_sector_size;
 
 		if (!work->tcon->posix_extensions) {
-			ksmbd_err("client doesn't negotiate with SMB3.1.1 POSIX Extensions\n");
+			pr_err("client doesn't negotiate with SMB3.1.1 POSIX Extensions\n");
 			rc = -EOPNOTSUPP;
 		} else {
 			info = (struct filesystem_posix_info *)(rsp->Buffer);
@@ -5213,7 +5213,7 @@ static int smb2_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 
 		len = strlen(new_name);
 		if (new_name[len - 1] != '/') {
-			ksmbd_err("not allow base filename in rename\n");
+			pr_err("not allow base filename in rename\n");
 			rc = -ESHARE;
 			goto out;
 		}
@@ -5229,8 +5229,8 @@ static int smb2_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 					xattr_stream_name,
 					NULL, 0, 0);
 		if (rc < 0) {
-			ksmbd_err("failed to store stream name in xattr: %d\n",
-				  rc);
+			pr_err("failed to store stream name in xattr: %d\n",
+			       rc);
 			rc = -EINVAL;
 			goto out;
 		}
@@ -5389,7 +5389,7 @@ static int set_file_basic_info(struct ksmbd_file *fp, char *buf,
 	if (file_info->Attributes) {
 		if (!S_ISDIR(inode->i_mode) &&
 		    file_info->Attributes & ATTR_DIRECTORY_LE) {
-			ksmbd_err("can't change a file to a directory\n");
+			pr_err("can't change a file to a directory\n");
 			return -EINVAL;
 		}
 
@@ -5467,7 +5467,7 @@ static int set_file_allocation_info(struct ksmbd_work *work,
 	if (alloc_blks > inode->i_blocks) {
 		rc = ksmbd_vfs_alloc_size(work, fp, alloc_blks * 512);
 		if (rc && rc != -EOPNOTSUPP) {
-			ksmbd_err("ksmbd_vfs_alloc_size is failed : %d\n", rc);
+			pr_err("ksmbd_vfs_alloc_size is failed : %d\n", rc);
 			return rc;
 		}
 	} else if (alloc_blks < inode->i_blocks) {
@@ -5483,8 +5483,8 @@ static int set_file_allocation_info(struct ksmbd_work *work,
 		size = i_size_read(inode);
 		rc = ksmbd_vfs_truncate(work, NULL, fp, alloc_blks * 512);
 		if (rc) {
-			ksmbd_err("truncate failed! filename : %s, err %d\n",
-				  fp->filename, rc);
+			pr_err("truncate failed! filename : %s, err %d\n",
+			       fp->filename, rc);
 			return rc;
 		}
 		if (size < alloc_blks * 512)
@@ -5536,7 +5536,7 @@ static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 	struct ksmbd_file *parent_fp;
 
 	if (!(fp->daccess & FILE_DELETE_LE)) {
-		ksmbd_err("no right to delete : 0x%x\n", fp->daccess);
+		pr_err("no right to delete : 0x%x\n", fp->daccess);
 		return -EACCES;
 	}
 
@@ -5546,7 +5546,7 @@ static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 	parent_fp = ksmbd_lookup_fd_inode(PARENT_INODE(fp));
 	if (parent_fp) {
 		if (parent_fp->daccess & FILE_DELETE_LE) {
-			ksmbd_err("parent dir is opened with delete access\n");
+			pr_err("parent dir is opened with delete access\n");
 			return -ESHARE;
 		}
 	}
@@ -5562,7 +5562,7 @@ static int set_file_disposition_info(struct ksmbd_file *fp, char *buf)
 	struct inode *inode;
 
 	if (!(fp->daccess & FILE_DELETE_LE)) {
-		ksmbd_err("no right to delete : 0x%x\n", fp->daccess);
+		pr_err("no right to delete : 0x%x\n", fp->daccess);
 		return -EACCES;
 	}
 
@@ -5594,8 +5594,8 @@ static int set_file_position_info(struct ksmbd_file *fp, char *buf)
 	if (current_byte_offset < 0 ||
 	    (fp->coption == FILE_NO_INTERMEDIATE_BUFFERING_LE &&
 	     current_byte_offset & (sector_size - 1))) {
-		ksmbd_err("CurrentByteOffset is not valid : %llu\n",
-			  current_byte_offset);
+		pr_err("CurrentByteOffset is not valid : %llu\n",
+		       current_byte_offset);
 		return -EINVAL;
 	}
 
@@ -5614,7 +5614,7 @@ static int set_file_mode_info(struct ksmbd_file *fp, char *buf)
 	if ((mode & ~FILE_MODE_INFO_MASK) ||
 	    (mode & FILE_SYNCHRONOUS_IO_ALERT_LE &&
 	     mode & FILE_SYNCHRONOUS_IO_NONALERT_LE)) {
-		ksmbd_err("Mode is not valid : 0x%x\n", le32_to_cpu(mode));
+		pr_err("Mode is not valid : 0x%x\n", le32_to_cpu(mode));
 		return -EINVAL;
 	}
 
@@ -5675,8 +5675,8 @@ static int smb2_set_info_file(struct ksmbd_work *work, struct ksmbd_file *fp,
 	case FILE_FULL_EA_INFORMATION:
 	{
 		if (!(fp->daccess & FILE_WRITE_EA_LE)) {
-			ksmbd_err("Not permitted to write ext  attr: 0x%x\n",
-				  fp->daccess);
+			pr_err("Not permitted to write ext  attr: 0x%x\n",
+			       fp->daccess);
 			return -EACCES;
 		}
 
@@ -5691,7 +5691,7 @@ static int smb2_set_info_file(struct ksmbd_work *work, struct ksmbd_file *fp,
 		return set_file_mode_info(fp, buf);
 	}
 
-	ksmbd_err("Unimplemented Fileinfoclass :%d\n", info_class);
+	pr_err("Unimplemented Fileinfoclass :%d\n", info_class);
 	return -EOPNOTSUPP;
 }
 
@@ -5919,7 +5919,7 @@ int smb2_read(struct ksmbd_work *work)
 	}
 
 	if (!(fp->daccess & (FILE_READ_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {
-		ksmbd_err("Not permitted to read : 0x%x\n", fp->daccess);
+		pr_err("Not permitted to read : 0x%x\n", fp->daccess);
 		err = -EACCES;
 		goto out;
 	}
@@ -6039,9 +6039,9 @@ static noinline int smb2_write_pipe(struct ksmbd_work *work)
 	} else {
 		if ((le16_to_cpu(req->DataOffset) > get_rfc1002_len(req)) ||
 		    (le16_to_cpu(req->DataOffset) + length > get_rfc1002_len(req))) {
-			ksmbd_err("invalid write data offset %u, smb_len %u\n",
-				  le16_to_cpu(req->DataOffset),
-				  get_rfc1002_len(req));
+			pr_err("invalid write data offset %u, smb_len %u\n",
+			       le16_to_cpu(req->DataOffset),
+			       get_rfc1002_len(req));
 			err = -EINVAL;
 			goto out;
 		}
@@ -6172,7 +6172,7 @@ int smb2_write(struct ksmbd_work *work)
 	}
 
 	if (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {
-		ksmbd_err("Not permitted to write : 0x%x\n", fp->daccess);
+		pr_err("Not permitted to write : 0x%x\n", fp->daccess);
 		err = -EACCES;
 		goto out;
 	}
@@ -6198,9 +6198,9 @@ int smb2_write(struct ksmbd_work *work)
 		} else {
 			if ((le16_to_cpu(req->DataOffset) > get_rfc1002_len(req)) ||
 			    (le16_to_cpu(req->DataOffset) + length > get_rfc1002_len(req))) {
-				ksmbd_err("invalid write data offset %u, smb_len %u\n",
-					  le16_to_cpu(req->DataOffset),
-					  get_rfc1002_len(req));
+				pr_err("invalid write data offset %u, smb_len %u\n",
+				       le16_to_cpu(req->DataOffset),
+				       get_rfc1002_len(req));
 				err = -EINVAL;
 				goto out;
 			}
@@ -6530,7 +6530,7 @@ int smb2_lock(struct ksmbd_work *work)
 		lock_start = le64_to_cpu(lock_ele[i].Offset);
 		lock_length = le64_to_cpu(lock_ele[i].Length);
 		if (lock_start > U64_MAX - lock_length) {
-			ksmbd_err("Invalid lock range requested\n");
+			pr_err("Invalid lock range requested\n");
 			rsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;
 			goto out;
 		}
@@ -6560,7 +6560,7 @@ int smb2_lock(struct ksmbd_work *work)
 			    cmp_lock->fl->fl_end >= flock->fl_end) {
 				if (cmp_lock->fl->fl_type != F_UNLCK &&
 				    flock->fl_type != F_UNLCK) {
-					ksmbd_err("conflict two locks in one request\n");
+					pr_err("conflict two locks in one request\n");
 					rsp->hdr.Status =
 						STATUS_INVALID_PARAMETER;
 					goto out;
@@ -6633,7 +6633,7 @@ int smb2_lock(struct ksmbd_work *work)
 			if (cmp_lock->zero_len && !smb_lock->zero_len &&
 			    cmp_lock->start > smb_lock->start &&
 			    cmp_lock->start < smb_lock->end) {
-				ksmbd_err("previous lock conflict with zero byte lock range\n");
+				pr_err("previous lock conflict with zero byte lock range\n");
 				rsp->hdr.Status = STATUS_LOCK_NOT_GRANTED;
 					goto out;
 			}
@@ -6641,7 +6641,7 @@ int smb2_lock(struct ksmbd_work *work)
 			if (smb_lock->zero_len && !cmp_lock->zero_len &&
 			    smb_lock->start > cmp_lock->start &&
 			    smb_lock->start < cmp_lock->end) {
-				ksmbd_err("current lock conflict with zero byte lock range\n");
+				pr_err("current lock conflict with zero byte lock range\n");
 				rsp->hdr.Status = STATUS_LOCK_NOT_GRANTED;
 					goto out;
 			}
@@ -6650,7 +6650,7 @@ int smb2_lock(struct ksmbd_work *work)
 			      cmp_lock->end > smb_lock->start) ||
 			     (cmp_lock->start < smb_lock->end && cmp_lock->end >= smb_lock->end)) &&
 			    !cmp_lock->zero_len && !smb_lock->zero_len) {
-				ksmbd_err("Not allow lock operation on exclusive lock range\n");
+				pr_err("Not allow lock operation on exclusive lock range\n");
 				rsp->hdr.Status =
 					STATUS_LOCK_NOT_GRANTED;
 				goto out;
@@ -6658,7 +6658,7 @@ int smb2_lock(struct ksmbd_work *work)
 		}
 
 		if (smb_lock->fl->fl_type == F_UNLCK && nolock) {
-			ksmbd_err("Try to unlock nolocked range\n");
+			pr_err("Try to unlock nolocked range\n");
 			rsp->hdr.Status = STATUS_RANGE_NOT_LOCKED;
 			goto out;
 		}
@@ -6787,7 +6787,7 @@ int smb2_lock(struct ksmbd_work *work)
 
 		err = ksmbd_vfs_lock(filp, 0, rlock);
 		if (err)
-			ksmbd_err("rollback unlock fail : %d\n", err);
+			pr_err("rollback unlock fail : %d\n", err);
 		list_del(&smb_lock->llist);
 		list_del(&smb_lock->glist);
 		locks_free_lock(smb_lock->fl);
@@ -6974,8 +6974,8 @@ static int fsctl_query_iface_info_ioctl(struct ksmbd_conn *conn,
 			netdev->ethtool_ops->get_link_ksettings(netdev, &cmd);
 			speed = cmd.base.speed;
 		} else {
-			ksmbd_err("%s %s\n", netdev->name,
-				  "speed is unknown, defaulting to 1Gb/sec");
+			pr_err("%s %s\n", netdev->name,
+			       "speed is unknown, defaulting to 1Gb/sec");
 			speed = SPEED_1000;
 		}
 
@@ -7387,7 +7387,7 @@ int smb2_ioctl(struct ksmbd_work *work)
 		reparse_ptr = (struct reparse_data_buffer *)&rsp->Buffer[0];
 		fp = ksmbd_lookup_fd_fast(work, id);
 		if (!fp) {
-			ksmbd_err("not found fp!!\n");
+			pr_err("not found fp!!\n");
 			ret = -ENOENT;
 			goto out;
 		}
@@ -7410,14 +7410,14 @@ int smb2_ioctl(struct ksmbd_work *work)
 		fp_in = ksmbd_lookup_fd_slow(work, dup_ext->VolatileFileHandle,
 					     dup_ext->PersistentFileHandle);
 		if (!fp_in) {
-			ksmbd_err("not found file handle in duplicate extent to file\n");
+			pr_err("not found file handle in duplicate extent to file\n");
 			ret = -ENOENT;
 			goto out;
 		}
 
 		fp_out = ksmbd_lookup_fd_fast(work, id);
 		if (!fp_out) {
-			ksmbd_err("not found fp\n");
+			pr_err("not found fp\n");
 			ret = -ENOENT;
 			goto dup_ext_out;
 		}
@@ -7514,7 +7514,7 @@ static void smb20_oplock_break_ack(struct ksmbd_work *work)
 
 	opinfo = opinfo_get(fp);
 	if (!opinfo) {
-		ksmbd_err("unexpected null oplock_info\n");
+		pr_err("unexpected null oplock_info\n");
 		rsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;
 		smb2_set_err_rsp(work);
 		ksmbd_fd_put(work, fp);
@@ -7577,8 +7577,8 @@ static void smb20_oplock_break_ack(struct ksmbd_work *work)
 		rsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;
 		break;
 	default:
-		ksmbd_err("unknown oplock change 0x%x -> 0x%x\n",
-			  opinfo->level, rsp_oplevel);
+		pr_err("unknown oplock change 0x%x -> 0x%x\n",
+		       opinfo->level, rsp_oplevel);
 	}
 
 	if (ret < 0) {
@@ -7654,8 +7654,8 @@ static void smb21_lease_break_ack(struct ksmbd_work *work)
 	lease = opinfo->o_lease;
 
 	if (opinfo->op_state == OPLOCK_STATE_NONE) {
-		ksmbd_err("unexpected lease break state 0x%x\n",
-			  opinfo->op_state);
+		pr_err("unexpected lease break state 0x%x\n",
+		       opinfo->op_state);
 		rsp->hdr.Status = STATUS_UNSUCCESSFUL;
 		goto err_out;
 	}
@@ -7868,7 +7868,7 @@ int smb2_check_sign_req(struct ksmbd_work *work)
 		return 0;
 
 	if (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {
-		ksmbd_err("bad smb2 signature\n");
+		pr_err("bad smb2 signature\n");
 		return 0;
 	}
 
@@ -7965,7 +7965,7 @@ int smb3_check_sign_req(struct ksmbd_work *work)
 	}
 
 	if (!signing_key) {
-		ksmbd_err("SMB3 signing key is not generated\n");
+		pr_err("SMB3 signing key is not generated\n");
 		return 0;
 	}
 
@@ -7978,7 +7978,7 @@ int smb3_check_sign_req(struct ksmbd_work *work)
 		return 0;
 
 	if (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {
-		ksmbd_err("bad smb2 signature\n");
+		pr_err("bad smb2 signature\n");
 		return 0;
 	}
 
@@ -8175,20 +8175,20 @@ int smb3_decrypt_req(struct ksmbd_work *work)
 
 	sess = ksmbd_session_lookup_all(conn, le64_to_cpu(tr_hdr->SessionId));
 	if (!sess) {
-		ksmbd_err("invalid session id(%llx) in transform header\n",
-			  le64_to_cpu(tr_hdr->SessionId));
+		pr_err("invalid session id(%llx) in transform header\n",
+		       le64_to_cpu(tr_hdr->SessionId));
 		return -ECONNABORTED;
 	}
 
 	if (pdu_length + 4 <
 	    sizeof(struct smb2_transform_hdr) + sizeof(struct smb2_hdr)) {
-		ksmbd_err("Transform message is too small (%u)\n",
-			  pdu_length);
+		pr_err("Transform message is too small (%u)\n",
+		       pdu_length);
 		return -ECONNABORTED;
 	}
 
 	if (pdu_length + 4 < orig_len + sizeof(struct smb2_transform_hdr)) {
-		ksmbd_err("Transform message is broken\n");
+		pr_err("Transform message is broken\n");
 		return -ECONNABORTED;
 	}
 
diff --git a/fs/cifsd/smb_common.c b/fs/cifsd/smb_common.c
index d74b2ce08187..5bf644d7e321 100644
--- a/fs/cifsd/smb_common.c
+++ b/fs/cifsd/smb_common.c
@@ -447,7 +447,7 @@ int ksmbd_smb_negotiate_common(struct ksmbd_work *work, unsigned int command)
 		return smb_handle_negotiate(work);
 	}
 
-	ksmbd_err("Unknown SMB negotiation command: %u\n", command);
+	pr_err("Unknown SMB negotiation command: %u\n", command);
 	return -EINVAL;
 }
 
diff --git a/fs/cifsd/smbacl.c b/fs/cifsd/smbacl.c
index 63db8c015f9d..23c952612db4 100644
--- a/fs/cifsd/smbacl.c
+++ b/fs/cifsd/smbacl.c
@@ -264,8 +264,8 @@ static int sid_to_id(struct smb_sid *psid, uint sidtype,
 	 * Just return an error.
 	 */
 	if (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {
-		ksmbd_err("%s: %u subauthorities is too many!\n",
-			  __func__, psid->num_subauth);
+		pr_err("%s: %u subauthorities is too many!\n",
+		       __func__, psid->num_subauth);
 		return -EIO;
 	}
 
@@ -383,7 +383,7 @@ static void parse_dacl(struct smb_acl *pdacl, char *end_of_acl,
 	/* validate that we do not go past end of acl */
 	if (end_of_acl <= (char *)pdacl ||
 	    end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {
-		ksmbd_err("ACL too small to parse DACL\n");
+		pr_err("ACL too small to parse DACL\n");
 		return;
 	}
 
@@ -477,8 +477,8 @@ static void parse_dacl(struct smb_acl *pdacl, char *end_of_acl,
 			temp_fattr.cf_uid = INVALID_UID;
 			ret = sid_to_id(&ppace[i]->sid, SIDOWNER, &temp_fattr);
 			if (ret || uid_eq(temp_fattr.cf_uid, INVALID_UID)) {
-				ksmbd_err("%s: Error %d mapping Owner SID to uid\n",
-					  __func__, ret);
+				pr_err("%s: Error %d mapping Owner SID to uid\n",
+				       __func__, ret);
 				continue;
 			}
 
@@ -764,7 +764,7 @@ static int parse_sid(struct smb_sid *psid, char *end_of_acl)
 	 * bytes long (assuming no sub-auths - e.g. the null SID
 	 */
 	if (end_of_acl < (char *)psid + 8) {
-		ksmbd_err("ACL too small to parse SID %p\n", psid);
+		pr_err("ACL too small to parse SID %p\n", psid);
 		return -EINVAL;
 	}
 
@@ -808,14 +808,14 @@ int parse_sec_desc(struct smb_ntsd *pntsd, int acl_len,
 	if (pntsd->osidoffset) {
 		rc = parse_sid(owner_sid_ptr, end_of_acl);
 		if (rc) {
-			ksmbd_err("%s: Error %d parsing Owner SID\n", __func__, rc);
+			pr_err("%s: Error %d parsing Owner SID\n", __func__, rc);
 			return rc;
 		}
 
 		rc = sid_to_id(owner_sid_ptr, SIDOWNER, fattr);
 		if (rc) {
-			ksmbd_err("%s: Error %d mapping Owner SID to uid\n",
-				  __func__, rc);
+			pr_err("%s: Error %d mapping Owner SID to uid\n",
+			       __func__, rc);
 			owner_sid_ptr = NULL;
 		}
 	}
@@ -823,14 +823,14 @@ int parse_sec_desc(struct smb_ntsd *pntsd, int acl_len,
 	if (pntsd->gsidoffset) {
 		rc = parse_sid(group_sid_ptr, end_of_acl);
 		if (rc) {
-			ksmbd_err("%s: Error %d mapping Owner SID to gid\n",
-				  __func__, rc);
+			pr_err("%s: Error %d mapping Owner SID to gid\n",
+			       __func__, rc);
 			return rc;
 		}
 		rc = sid_to_id(group_sid_ptr, SIDUNIX_GROUP, fattr);
 		if (rc) {
-			ksmbd_err("%s: Error %d mapping Group SID to gid\n",
-				  __func__, rc);
+			pr_err("%s: Error %d mapping Group SID to gid\n",
+			       __func__, rc);
 			group_sid_ptr = NULL;
 		}
 	}
diff --git a/fs/cifsd/transport_ipc.c b/fs/cifsd/transport_ipc.c
index 2bcc1cad6037..13eacfda64ac 100644
--- a/fs/cifsd/transport_ipc.c
+++ b/fs/cifsd/transport_ipc.c
@@ -43,11 +43,11 @@ static unsigned int ksmbd_tools_pid;
 static bool ksmbd_ipc_validate_version(struct genl_info *m)
 {
 	if (m->genlhdr->version != KSMBD_GENL_VERSION) {
-		ksmbd_err("%s. ksmbd: %d, kernel module: %d. %s.\n",
-			  "Daemon and kernel module version mismatch",
-			  m->genlhdr->version,
-			  KSMBD_GENL_VERSION,
-			  "User-space ksmbd should terminate");
+		pr_err("%s. ksmbd: %d, kernel module: %d. %s.\n",
+		       "Daemon and kernel module version mismatch",
+		       m->genlhdr->version,
+		       KSMBD_GENL_VERSION,
+		       "User-space ksmbd should terminate");
 		return false;
 	}
 	return true;
@@ -267,8 +267,8 @@ static int handle_response(int type, void *payload, size_t sz)
 		 * request message type + 1.
 		 */
 		if (entry->type + 1 != type) {
-			ksmbd_err("Waiting for IPC type %d, got %d. Ignore.\n",
-				  entry->type + 1, type);
+			pr_err("Waiting for IPC type %d, got %d. Ignore.\n",
+			       entry->type + 1, type);
 		}
 
 		entry->response = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);
@@ -313,9 +313,9 @@ static int ipc_server_config_on_startup(struct ksmbd_startup_request *req)
 	ret |= ksmbd_tcp_set_interfaces(KSMBD_STARTUP_CONFIG_INTERFACES(req),
 					req->ifc_list_sz);
 	if (ret) {
-		ksmbd_err("Server configuration error: %s %s %s\n",
-			  req->netbios_name, req->server_string,
-			  req->work_group);
+		pr_err("Server configuration error: %s %s %s\n",
+		       req->netbios_name, req->server_string,
+		       req->work_group);
 		return ret;
 	}
 
@@ -353,7 +353,7 @@ static int handle_startup_event(struct sk_buff *skb, struct genl_info *info)
 	mutex_lock(&startup_lock);
 	if (!ksmbd_server_configurable()) {
 		mutex_unlock(&startup_lock);
-		ksmbd_err("Server reset is in progress, can't start daemon\n");
+		pr_err("Server reset is in progress, can't start daemon\n");
 		return -EINVAL;
 	}
 
@@ -363,7 +363,7 @@ static int handle_startup_event(struct sk_buff *skb, struct genl_info *info)
 			goto out;
 		}
 
-		ksmbd_err("Reconnect to a new user space daemon\n");
+		pr_err("Reconnect to a new user space daemon\n");
 	} else {
 		struct ksmbd_startup_request *req;
 
@@ -384,7 +384,7 @@ static int handle_startup_event(struct sk_buff *skb, struct genl_info *info)
 
 static int handle_unsupported_event(struct sk_buff *skb, struct genl_info *info)
 {
-	ksmbd_err("Unknown IPC event: %d, ignore.\n", info->genlhdr->cmd);
+	pr_err("Unknown IPC event: %d, ignore.\n", info->genlhdr->cmd);
 	return -EINVAL;
 }
 
@@ -827,7 +827,7 @@ static int __ipc_heartbeat(void)
 	WRITE_ONCE(server_conf.state, SERVER_STATE_RESETTING);
 	server_conf.ipc_last_active = 0;
 	ksmbd_tools_pid = 0;
-	ksmbd_err("No IPC daemon response for %lus\n", delta / HZ);
+	pr_err("No IPC daemon response for %lus\n", delta / HZ);
 	mutex_unlock(&startup_lock);
 	return -EINVAL;
 }
@@ -871,7 +871,7 @@ int ksmbd_ipc_init(void)
 
 	ret = genl_register_family(&ksmbd_genl_family);
 	if (ret) {
-		ksmbd_err("Failed to register KSMBD netlink interface %d\n", ret);
+		pr_err("Failed to register KSMBD netlink interface %d\n", ret);
 		cancel_delayed_work_sync(&ipc_timer_work);
 	}
 
diff --git a/fs/cifsd/transport_rdma.c b/fs/cifsd/transport_rdma.c
index 52237f023b66..bd7a090d5350 100644
--- a/fs/cifsd/transport_rdma.c
+++ b/fs/cifsd/transport_rdma.c
@@ -525,9 +525,9 @@ static void recv_done(struct ib_cq *cq, struct ib_wc *wc)
 
 	if (wc->status != IB_WC_SUCCESS || wc->opcode != IB_WC_RECV) {
 		if (wc->status != IB_WC_WR_FLUSH_ERR) {
-			ksmbd_err("Recv error. status='%s (%d)' opcode=%d\n",
-				  ib_wc_status_msg(wc->status), wc->status,
-				  wc->opcode);
+			pr_err("Recv error. status='%s (%d)' opcode=%d\n",
+			       ib_wc_status_msg(wc->status), wc->status,
+			       wc->opcode);
 			smb_direct_disconnect_rdma_connection(t);
 		}
 		put_empty_recvmsg(t, recvmsg);
@@ -623,7 +623,7 @@ static int smb_direct_post_recv(struct smb_direct_transport *t,
 
 	ret = ib_post_recv(t->qp, &wr, NULL);
 	if (ret) {
-		ksmbd_err("Can't post recv: %d\n", ret);
+		pr_err("Can't post recv: %d\n", ret);
 		ib_dma_unmap_single(t->cm_id->device,
 				    recvmsg->sge.addr, recvmsg->sge.length,
 				    DMA_FROM_DEVICE);
@@ -645,7 +645,7 @@ static int smb_direct_read(struct ksmbd_transport *t, char *buf,
 
 again:
 	if (st->status != SMB_DIRECT_CS_CONNECTED) {
-		ksmbd_err("disconnected\n");
+		pr_err("disconnected\n");
 		return -ENOTCONN;
 	}
 
@@ -794,7 +794,7 @@ static void smb_direct_post_recv_credits(struct work_struct *work)
 
 			ret = smb_direct_post_recv(t, recvmsg);
 			if (ret) {
-				ksmbd_err("Can't post recv: %d\n", ret);
+				pr_err("Can't post recv: %d\n", ret);
 				put_recvmsg(t, recvmsg);
 				break;
 			}
@@ -829,9 +829,9 @@ static void send_done(struct ib_cq *cq, struct ib_wc *wc)
 		    wc->opcode);
 
 	if (wc->status != IB_WC_SUCCESS || wc->opcode != IB_WC_SEND) {
-		ksmbd_err("Send error. status='%s (%d)', opcode=%d\n",
-			  ib_wc_status_msg(wc->status), wc->status,
-			  wc->opcode);
+		pr_err("Send error. status='%s (%d)', opcode=%d\n",
+		       ib_wc_status_msg(wc->status), wc->status,
+		       wc->opcode);
 		smb_direct_disconnect_rdma_connection(t);
 	}
 
@@ -880,7 +880,7 @@ static int smb_direct_post_send(struct smb_direct_transport *t,
 
 	ret = ib_post_send(t->qp, wr, NULL);
 	if (ret) {
-		ksmbd_err("failed to post send: %d\n", ret);
+		pr_err("failed to post send: %d\n", ret);
 		if (wr->num_sge > 1) {
 			if (atomic_dec_and_test(&t->send_payload_pending))
 				wake_up(&t->wait_send_payload_pending);
@@ -1158,11 +1158,11 @@ static int smb_direct_post_send_data(struct smb_direct_transport *t,
 					    sg, SMB_DIRECT_MAX_SEND_SGES - 1,
 					    DMA_TO_DEVICE);
 		if (sg_cnt <= 0) {
-			ksmbd_err("failed to map buffer\n");
+			pr_err("failed to map buffer\n");
 			ret = -ENOMEM;
 			goto err;
 		} else if (sg_cnt + msg->num_sge > SMB_DIRECT_MAX_SEND_SGES - 1) {
-			ksmbd_err("buffer not fitted into sges\n");
+			pr_err("buffer not fitted into sges\n");
 			ret = -E2BIG;
 			ib_dma_unmap_sg(t->cm_id->device, sg, sg_cnt,
 					DMA_TO_DEVICE);
@@ -1290,8 +1290,8 @@ static void read_write_done(struct ib_cq *cq, struct ib_wc *wc,
 	struct smb_direct_transport *t = msg->t;
 
 	if (wc->status != IB_WC_SUCCESS) {
-		ksmbd_err("read/write error. opcode = %d, status = %s(%d)\n",
-			  wc->opcode, ib_wc_status_msg(wc->status), wc->status);
+		pr_err("read/write error. opcode = %d, status = %s(%d)\n",
+		       wc->opcode, ib_wc_status_msg(wc->status), wc->status);
 		smb_direct_disconnect_rdma_connection(t);
 	}
 
@@ -1348,7 +1348,7 @@ static int smb_direct_rdma_xmit(struct smb_direct_transport *t, void *buf,
 
 	ret = get_sg_list(buf, buf_len, msg->sgt.sgl, msg->sgt.orig_nents);
 	if (ret <= 0) {
-		ksmbd_err("failed to get pages\n");
+		pr_err("failed to get pages\n");
 		goto err;
 	}
 
@@ -1357,7 +1357,7 @@ static int smb_direct_rdma_xmit(struct smb_direct_transport *t, void *buf,
 			       0, remote_offset, remote_key,
 			       is_read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 	if (ret < 0) {
-		ksmbd_err("failed to init rdma_rw_ctx: %d\n", ret);
+		pr_err("failed to init rdma_rw_ctx: %d\n", ret);
 		goto err;
 	}
 
@@ -1369,7 +1369,7 @@ static int smb_direct_rdma_xmit(struct smb_direct_transport *t, void *buf,
 
 	ret = ib_post_send(t->qp, first_wr, NULL);
 	if (ret) {
-		ksmbd_err("failed to post send wr: %d\n", ret);
+		pr_err("failed to post send wr: %d\n", ret);
 		goto err;
 	}
 
@@ -1445,9 +1445,9 @@ static int smb_direct_cm_handler(struct rdma_cm_id *cm_id,
 		break;
 	}
 	default:
-		ksmbd_err("Unexpected RDMA CM event. cm_id=%p, event=%s (%d)\n",
-			  cm_id, rdma_event_msg(event->event),
-			  event->event);
+		pr_err("Unexpected RDMA CM event. cm_id=%p, event=%s (%d)\n",
+		       cm_id, rdma_event_msg(event->event),
+		       event->event);
 		break;
 	}
 	return 0;
@@ -1557,7 +1557,7 @@ static int smb_direct_accept_client(struct smb_direct_transport *t)
 
 	ret = rdma_accept(t->cm_id, &conn_param);
 	if (ret) {
-		ksmbd_err("error at rdma_accept: %d\n", ret);
+		pr_err("error at rdma_accept: %d\n", ret);
 		return ret;
 	}
 
@@ -1581,14 +1581,14 @@ static int smb_direct_negotiate(struct smb_direct_transport *t)
 
 	ret = smb_direct_post_recv(t, recvmsg);
 	if (ret) {
-		ksmbd_err("Can't post recv: %d\n", ret);
+		pr_err("Can't post recv: %d\n", ret);
 		goto out;
 	}
 
 	t->negotiation_requested = false;
 	ret = smb_direct_accept_client(t);
 	if (ret) {
-		ksmbd_err("Can't accept client\n");
+		pr_err("Can't accept client\n");
 		goto out;
 	}
 
@@ -1635,7 +1635,7 @@ static int smb_direct_init_params(struct smb_direct_transport *t,
 	t->max_send_size = smb_direct_max_send_size;
 	max_send_sges = DIV_ROUND_UP(t->max_send_size, PAGE_SIZE) + 2;
 	if (max_send_sges > SMB_DIRECT_MAX_SEND_SGES) {
-		ksmbd_err("max_send_size %d is too large\n", t->max_send_size);
+		pr_err("max_send_size %d is too large\n", t->max_send_size);
 		return -EINVAL;
 	}
 
@@ -1655,31 +1655,31 @@ static int smb_direct_init_params(struct smb_direct_transport *t,
 	max_send_wrs = smb_direct_send_credit_target + max_rw_wrs;
 	if (max_send_wrs > device->attrs.max_cqe ||
 	    max_send_wrs > device->attrs.max_qp_wr) {
-		ksmbd_err("consider lowering send_credit_target = %d, or max_outstanding_rw_ops = %d\n",
-			  smb_direct_send_credit_target,
-			  smb_direct_max_outstanding_rw_ops);
-		ksmbd_err("Possible CQE overrun, device reporting max_cqe %d max_qp_wr %d\n",
-			  device->attrs.max_cqe, device->attrs.max_qp_wr);
+		pr_err("consider lowering send_credit_target = %d, or max_outstanding_rw_ops = %d\n",
+		       smb_direct_send_credit_target,
+		       smb_direct_max_outstanding_rw_ops);
+		pr_err("Possible CQE overrun, device reporting max_cqe %d max_qp_wr %d\n",
+		       device->attrs.max_cqe, device->attrs.max_qp_wr);
 		return -EINVAL;
 	}
 
 	if (smb_direct_receive_credit_max > device->attrs.max_cqe ||
 	    smb_direct_receive_credit_max > device->attrs.max_qp_wr) {
-		ksmbd_err("consider lowering receive_credit_max = %d\n",
-			  smb_direct_receive_credit_max);
-		ksmbd_err("Possible CQE overrun, device reporting max_cpe %d max_qp_wr %d\n",
-			  device->attrs.max_cqe, device->attrs.max_qp_wr);
+		pr_err("consider lowering receive_credit_max = %d\n",
+		       smb_direct_receive_credit_max);
+		pr_err("Possible CQE overrun, device reporting max_cpe %d max_qp_wr %d\n",
+		       device->attrs.max_cqe, device->attrs.max_qp_wr);
 		return -EINVAL;
 	}
 
 	if (device->attrs.max_send_sge < SMB_DIRECT_MAX_SEND_SGES) {
-		ksmbd_err("warning: device max_send_sge = %d too small\n",
-			  device->attrs.max_send_sge);
+		pr_err("warning: device max_send_sge = %d too small\n",
+		       device->attrs.max_send_sge);
 		return -EINVAL;
 	}
 	if (device->attrs.max_recv_sge < SMB_DIRECT_MAX_RECV_SGES) {
-		ksmbd_err("warning: device max_recv_sge = %d too small\n",
-			  device->attrs.max_recv_sge);
+		pr_err("warning: device max_recv_sge = %d too small\n",
+		       device->attrs.max_recv_sge);
 		return -EINVAL;
 	}
 
@@ -1788,7 +1788,7 @@ static int smb_direct_create_qpair(struct smb_direct_transport *t,
 
 	t->pd = ib_alloc_pd(t->cm_id->device, 0);
 	if (IS_ERR(t->pd)) {
-		ksmbd_err("Can't create RDMA PD\n");
+		pr_err("Can't create RDMA PD\n");
 		ret = PTR_ERR(t->pd);
 		t->pd = NULL;
 		return ret;
@@ -1797,7 +1797,7 @@ static int smb_direct_create_qpair(struct smb_direct_transport *t,
 	t->send_cq = ib_alloc_cq(t->cm_id->device, t,
 				 t->send_credit_target, 0, IB_POLL_WORKQUEUE);
 	if (IS_ERR(t->send_cq)) {
-		ksmbd_err("Can't create RDMA send CQ\n");
+		pr_err("Can't create RDMA send CQ\n");
 		ret = PTR_ERR(t->send_cq);
 		t->send_cq = NULL;
 		goto err;
@@ -1807,7 +1807,7 @@ static int smb_direct_create_qpair(struct smb_direct_transport *t,
 				 cap->max_send_wr + cap->max_rdma_ctxs,
 				 0, IB_POLL_WORKQUEUE);
 	if (IS_ERR(t->recv_cq)) {
-		ksmbd_err("Can't create RDMA recv CQ\n");
+		pr_err("Can't create RDMA recv CQ\n");
 		ret = PTR_ERR(t->recv_cq);
 		t->recv_cq = NULL;
 		goto err;
@@ -1825,7 +1825,7 @@ static int smb_direct_create_qpair(struct smb_direct_transport *t,
 
 	ret = rdma_create_qp(t->cm_id, t->pd, &qp_attr);
 	if (ret) {
-		ksmbd_err("Can't create RDMA QP: %d\n", ret);
+		pr_err("Can't create RDMA QP: %d\n", ret);
 		goto err;
 	}
 
@@ -1861,25 +1861,25 @@ static int smb_direct_prepare(struct ksmbd_transport *t)
 
 	ret = smb_direct_init_params(st, &qp_cap);
 	if (ret) {
-		ksmbd_err("Can't configure RDMA parameters\n");
+		pr_err("Can't configure RDMA parameters\n");
 		return ret;
 	}
 
 	ret = smb_direct_create_pools(st);
 	if (ret) {
-		ksmbd_err("Can't init RDMA pool: %d\n", ret);
+		pr_err("Can't init RDMA pool: %d\n", ret);
 		return ret;
 	}
 
 	ret = smb_direct_create_qpair(st, &qp_cap);
 	if (ret) {
-		ksmbd_err("Can't accept RDMA client: %d\n", ret);
+		pr_err("Can't accept RDMA client: %d\n", ret);
 		return ret;
 	}
 
 	ret = smb_direct_negotiate(st);
 	if (ret) {
-		ksmbd_err("Can't negotiate: %d\n", ret);
+		pr_err("Can't negotiate: %d\n", ret);
 		return ret;
 	}
 
@@ -1917,7 +1917,7 @@ static int smb_direct_handle_connect_request(struct rdma_cm_id *new_cm_id)
 	if (IS_ERR(KSMBD_TRANS(t)->handler)) {
 		int ret = PTR_ERR(KSMBD_TRANS(t)->handler);
 
-		ksmbd_err("Can't start thread\n");
+		pr_err("Can't start thread\n");
 		free_transport(t);
 		return ret;
 	}
@@ -1933,7 +1933,7 @@ static int smb_direct_listen_handler(struct rdma_cm_id *cm_id,
 		int ret = smb_direct_handle_connect_request(cm_id);
 
 		if (ret) {
-			ksmbd_err("Can't create transport: %d\n", ret);
+			pr_err("Can't create transport: %d\n", ret);
 			return ret;
 		}
 
@@ -1942,8 +1942,8 @@ static int smb_direct_listen_handler(struct rdma_cm_id *cm_id,
 		break;
 	}
 	default:
-		ksmbd_err("Unexpected listen event. cm_id=%p, event=%s (%d)\n",
-			  cm_id, rdma_event_msg(event->event), event->event);
+		pr_err("Unexpected listen event. cm_id=%p, event=%s (%d)\n",
+		       cm_id, rdma_event_msg(event->event), event->event);
 		break;
 	}
 	return 0;
@@ -1962,13 +1962,13 @@ static int smb_direct_listen(int port)
 	cm_id = rdma_create_id(&init_net, smb_direct_listen_handler,
 			       &smb_direct_listener, RDMA_PS_TCP, IB_QPT_RC);
 	if (IS_ERR(cm_id)) {
-		ksmbd_err("Can't create cm id: %ld\n", PTR_ERR(cm_id));
+		pr_err("Can't create cm id: %ld\n", PTR_ERR(cm_id));
 		return PTR_ERR(cm_id);
 	}
 
 	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);
 	if (ret) {
-		ksmbd_err("Can't bind: %d\n", ret);
+		pr_err("Can't bind: %d\n", ret);
 		goto err;
 	}
 
@@ -1976,7 +1976,7 @@ static int smb_direct_listen(int port)
 
 	ret = rdma_listen(cm_id, 10);
 	if (ret) {
-		ksmbd_err("Can't listen: %d\n", ret);
+		pr_err("Can't listen: %d\n", ret);
 		goto err;
 	}
 	return 0;
@@ -2006,7 +2006,7 @@ int ksmbd_rdma_init(void)
 	if (ret) {
 		destroy_workqueue(smb_direct_wq);
 		smb_direct_wq = NULL;
-		ksmbd_err("Can't listen: %d\n", ret);
+		pr_err("Can't listen: %d\n", ret);
 		return ret;
 	}
 
diff --git a/fs/cifsd/transport_tcp.c b/fs/cifsd/transport_tcp.c
index 16702b7874f4..56ec11ff5a9f 100644
--- a/fs/cifsd/transport_tcp.c
+++ b/fs/cifsd/transport_tcp.c
@@ -190,7 +190,7 @@ static int ksmbd_tcp_new_connection(struct socket *client_sk)
 
 	csin = KSMBD_TCP_PEER_SOCKADDR(KSMBD_TRANS(t)->conn);
 	if (kernel_getpeername(client_sk, csin) < 0) {
-		ksmbd_err("client ip resolution failed\n");
+		pr_err("client ip resolution failed\n");
 		rc = -EINVAL;
 		goto out_error;
 	}
@@ -200,7 +200,7 @@ static int ksmbd_tcp_new_connection(struct socket *client_sk)
 					      "ksmbd:%u",
 					      ksmbd_tcp_get_port(csin));
 	if (IS_ERR(KSMBD_TRANS(t)->handler)) {
-		ksmbd_err("cannot start conn thread\n");
+		pr_err("cannot start conn thread\n");
 		rc = PTR_ERR(KSMBD_TRANS(t)->handler);
 		free_transport(t);
 	}
@@ -380,7 +380,7 @@ static void tcp_destroy_socket(struct socket *ksmbd_socket)
 
 	ret = kernel_sock_shutdown(ksmbd_socket, SHUT_RDWR);
 	if (ret)
-		ksmbd_err("Failed to shutdown socket: %d\n", ret);
+		pr_err("Failed to shutdown socket: %d\n", ret);
 	else
 		sock_release(ksmbd_socket);
 }
@@ -400,11 +400,11 @@ static int create_socket(struct interface *iface)
 
 	ret = sock_create(PF_INET6, SOCK_STREAM, IPPROTO_TCP, &ksmbd_socket);
 	if (ret) {
-		ksmbd_err("Can't create socket for ipv6, try ipv4: %d\n", ret);
+		pr_err("Can't create socket for ipv6, try ipv4: %d\n", ret);
 		ret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP,
 				  &ksmbd_socket);
 		if (ret) {
-			ksmbd_err("Can't create socket for ipv4: %d\n", ret);
+			pr_err("Can't create socket for ipv4: %d\n", ret);
 			goto out_error;
 		}
 
@@ -427,7 +427,7 @@ static int create_socket(struct interface *iface)
 			      KERNEL_SOCKPTR(iface->name),
 			      strlen(iface->name));
 	if (ret != -ENODEV && ret < 0) {
-		ksmbd_err("Failed to set SO_BINDTODEVICE: %d\n", ret);
+		pr_err("Failed to set SO_BINDTODEVICE: %d\n", ret);
 		goto out_error;
 	}
 
@@ -438,7 +438,7 @@ static int create_socket(struct interface *iface)
 		ret = kernel_bind(ksmbd_socket, (struct sockaddr *)&sin6,
 				  sizeof(sin6));
 	if (ret) {
-		ksmbd_err("Failed to bind socket: %d\n", ret);
+		pr_err("Failed to bind socket: %d\n", ret);
 		goto out_error;
 	}
 
@@ -447,14 +447,14 @@ static int create_socket(struct interface *iface)
 
 	ret = kernel_listen(ksmbd_socket, KSMBD_SOCKET_BACKLOG);
 	if (ret) {
-		ksmbd_err("Port listen() error: %d\n", ret);
+		pr_err("Port listen() error: %d\n", ret);
 		goto out_error;
 	}
 
 	iface->ksmbd_socket = ksmbd_socket;
 	ret = ksmbd_tcp_run_kthread(iface);
 	if (ret) {
-		ksmbd_err("Can't start ksmbd main kthread: %d\n", ret);
+		pr_err("Can't start ksmbd main kthread: %d\n", ret);
 		goto out_error;
 	}
 	iface->state = IFACE_STATE_CONFIGURED;
@@ -540,7 +540,7 @@ static void tcp_stop_kthread(struct task_struct *kthread)
 
 	ret = kthread_stop(kthread);
 	if (ret)
-		ksmbd_err("failed to stop forker thread\n");
+		pr_err("failed to stop forker thread\n");
 }
 
 void ksmbd_tcp_destroy(void)
diff --git a/fs/cifsd/vfs.c b/fs/cifsd/vfs.c
index ef74e56cd05f..ad08bad8df4e 100644
--- a/fs/cifsd/vfs.c
+++ b/fs/cifsd/vfs.c
@@ -45,7 +45,7 @@ static char *extract_last_component(char *path)
 		p++;
 	} else {
 		p = NULL;
-		ksmbd_err("Invalid path %s\n", path);
+		pr_err("Invalid path %s\n", path);
 	}
 	return p;
 }
@@ -170,8 +170,8 @@ int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
 		if (err != -ENOENT)
-			ksmbd_err("path create failed for %s, err %d\n",
-				  name, err);
+			pr_err("path create failed for %s, err %d\n",
+			       name, err);
 		return err;
 	}
 
@@ -181,7 +181,7 @@ int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)
 		ksmbd_vfs_inherit_owner(work, d_inode(path.dentry),
 					d_inode(dentry));
 	} else {
-		ksmbd_err("File(%s): creation failed (err:%d)\n", name, err);
+		pr_err("File(%s): creation failed (err:%d)\n", name, err);
 	}
 	done_path_create(&path, dentry);
 	return err;
@@ -235,7 +235,7 @@ int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)
 out:
 	done_path_create(&path, dentry);
 	if (err)
-		ksmbd_err("mkdir(%s): creation failed (err:%d)\n", name, err);
+		pr_err("mkdir(%s): creation failed (err:%d)\n", name, err);
 	return err;
 }
 
@@ -259,7 +259,7 @@ static ssize_t ksmbd_vfs_getcasexattr(struct dentry *dentry, char *attr_name,
 					       name,
 					       attr_value);
 		if (value_len < 0)
-			ksmbd_err("failed to get xattr in file\n");
+			pr_err("failed to get xattr in file\n");
 		break;
 	}
 
@@ -324,7 +324,7 @@ static int check_lock_range(struct file *filp, loff_t start, loff_t end,
 		if (flock->fl_end >= start && end >= flock->fl_start) {
 			if (flock->fl_type == F_RDLCK) {
 				if (type == WRITE) {
-					ksmbd_err("not allow write by shared lock\n");
+					pr_err("not allow write by shared lock\n");
 					error = 1;
 					goto out;
 				}
@@ -332,7 +332,7 @@ static int check_lock_range(struct file *filp, loff_t start, loff_t end,
 				/* check owner in lock */
 				if (flock->fl_file != filp) {
 					error = 1;
-					ksmbd_err("not allow rw access by exclusive lock from other opens\n");
+					pr_err("not allow rw access by exclusive lock from other opens\n");
 					goto out;
 				}
 			}
@@ -368,7 +368,7 @@ int ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp, size_t count,
 
 	if (work->conn->connection_type) {
 		if (!(fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {
-			ksmbd_err("no right to read(%s)\n", FP_FILENAME(fp));
+			pr_err("no right to read(%s)\n", FP_FILENAME(fp));
 			return -EACCES;
 		}
 	}
@@ -381,15 +381,15 @@ int ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp, size_t count,
 
 		ret = check_lock_range(filp, *pos, *pos + count - 1, READ);
 		if (ret) {
-			ksmbd_err("unable to read due to lock\n");
+			pr_err("unable to read due to lock\n");
 			return -EAGAIN;
 		}
 	}
 
 	nbytes = kernel_read(filp, rbuf, count, pos);
 	if (nbytes < 0) {
-		ksmbd_err("smb read failed for (%s), err = %zd\n",
-			  fp->filename, nbytes);
+		pr_err("smb read failed for (%s), err = %zd\n",
+		       fp->filename, nbytes);
 		return nbytes;
 	}
 
@@ -418,7 +418,7 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,
 				       fp->stream.size,
 				       &stream_buf);
 	if ((int)v_len < 0) {
-		ksmbd_err("not found stream in xattr : %zd\n", v_len);
+		pr_err("not found stream in xattr : %zd\n", v_len);
 		err = (int)v_len;
 		goto out;
 	}
@@ -476,7 +476,7 @@ int ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,
 
 	if (sess->conn->connection_type) {
 		if (!(fp->daccess & FILE_WRITE_DATA_LE)) {
-			ksmbd_err("no right to write(%s)\n", FP_FILENAME(fp));
+			pr_err("no right to write(%s)\n", FP_FILENAME(fp));
 			err = -EACCES;
 			goto out;
 		}
@@ -494,7 +494,7 @@ int ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,
 	if (!work->tcon->posix_extensions) {
 		err = check_lock_range(filp, *pos, *pos + count - 1, WRITE);
 		if (err) {
-			ksmbd_err("unable to write due to lock\n");
+			pr_err("unable to write due to lock\n");
 			err = -EAGAIN;
 			goto out;
 		}
@@ -515,8 +515,8 @@ int ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,
 	if (sync) {
 		err = vfs_fsync_range(filp, offset, offset + *written, 0);
 		if (err < 0)
-			ksmbd_err("fsync failed for filename = %s, err = %d\n",
-				  FP_FILENAME(fp), err);
+			pr_err("fsync failed for filename = %s, err = %d\n",
+			       FP_FILENAME(fp), err);
 	}
 
 out:
@@ -537,7 +537,7 @@ int ksmbd_vfs_getattr(struct path *path, struct kstat *stat)
 
 	err = vfs_getattr(path, stat, STATX_BTIME, AT_STATX_SYNC_AS_STAT);
 	if (err)
-		ksmbd_err("getattr failed, err %d\n", err);
+		pr_err("getattr failed, err %d\n", err);
 	return err;
 }
 
@@ -555,12 +555,12 @@ int ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id)
 
 	fp = ksmbd_lookup_fd_slow(work, fid, p_id);
 	if (!fp) {
-		ksmbd_err("failed to get filp for fid %llu\n", fid);
+		pr_err("failed to get filp for fid %llu\n", fid);
 		return -ENOENT;
 	}
 	err = vfs_fsync(fp->filp, 0);
 	if (err < 0)
-		ksmbd_err("smb fsync failed, err = %d\n", err);
+		pr_err("smb fsync failed, err = %d\n", err);
 	ksmbd_fd_put(work, fp);
 	return err;
 }
@@ -654,8 +654,8 @@ int ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,
 
 	err = kern_path(oldname, flags, &oldpath);
 	if (err) {
-		ksmbd_err("cannot get linux path for %s, err = %d\n",
-			  oldname, err);
+		pr_err("cannot get linux path for %s, err = %d\n",
+		       oldname, err);
 		goto out1;
 	}
 
@@ -663,13 +663,13 @@ int ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,
 				  flags | LOOKUP_REVAL);
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
-		ksmbd_err("path create err for %s, err %d\n", newname, err);
+		pr_err("path create err for %s, err %d\n", newname, err);
 		goto out2;
 	}
 
 	err = -EXDEV;
 	if (oldpath.mnt != newpath.mnt) {
-		ksmbd_err("vfs_link failed err %d\n", err);
+		pr_err("vfs_link failed err %d\n", err);
 		goto out3;
 	}
 
@@ -730,7 +730,7 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 	dst_dent = lookup_one_len(dst_name, dst_dent_parent, strlen(dst_name));
 	err = PTR_ERR(dst_dent);
 	if (IS_ERR(dst_dent)) {
-		ksmbd_err("lookup failed %s [%d]\n", dst_name, err);
+		pr_err("lookup failed %s [%d]\n", dst_name, err);
 		goto out;
 	}
 
@@ -747,7 +747,7 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 		err = vfs_rename(&rd);
 	}
 	if (err)
-		ksmbd_err("vfs_rename failed err %d\n", err);
+		pr_err("vfs_rename failed err %d\n", err);
 	if (dst_dent)
 		dput(dst_dent);
 out:
@@ -835,14 +835,14 @@ int ksmbd_vfs_truncate(struct ksmbd_work *work, const char *name,
 	if (name) {
 		err = kern_path(name, 0, &path);
 		if (err) {
-			ksmbd_err("cannot get linux path for %s, err %d\n",
-				  name, err);
+			pr_err("cannot get linux path for %s, err %d\n",
+			       name, err);
 			return err;
 		}
 		err = vfs_truncate(&path, size);
 		if (err)
-			ksmbd_err("truncate failed for %s err %d\n",
-				  name, err);
+			pr_err("truncate failed for %s err %d\n",
+			       name, err);
 		path_put(&path);
 	} else {
 		struct file *filp;
@@ -864,15 +864,15 @@ int ksmbd_vfs_truncate(struct ksmbd_work *work, const char *name,
 			}
 
 			if (err) {
-				ksmbd_err("failed due to lock\n");
+				pr_err("failed due to lock\n");
 				return -EAGAIN;
 			}
 		}
 
 		err = vfs_truncate(&filp->f_path, size);
 		if (err)
-			ksmbd_err("truncate failed for filename : %s err %d\n",
-				  fp->filename, err);
+			pr_err("truncate failed for filename : %s err %d\n",
+			       fp->filename, err);
 	}
 
 	return err;
@@ -1458,7 +1458,7 @@ static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct inode *inode,
 			xa_entry->type = SMB_ACL_MASK;
 			break;
 		default:
-			ksmbd_err("unknown type : 0x%x\n", pa_entry->e_tag);
+			pr_err("unknown type : 0x%x\n", pa_entry->e_tag);
 			goto out;
 		}
 
@@ -1502,7 +1502,7 @@ int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn, struct dentry *dentry,
 
 	rc = ksmbd_gen_sd_hash(conn, acl.sd_buf, acl.sd_size, acl.hash);
 	if (rc) {
-		ksmbd_err("failed to generate hash for ndr acl\n");
+		pr_err("failed to generate hash for ndr acl\n");
 		return rc;
 	}
 
@@ -1513,27 +1513,27 @@ int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn, struct dentry *dentry,
 
 	rc = ndr_encode_posix_acl(&acl_ndr, inode, smb_acl, def_smb_acl);
 	if (rc) {
-		ksmbd_err("failed to encode ndr to posix acl\n");
+		pr_err("failed to encode ndr to posix acl\n");
 		goto out;
 	}
 
 	rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset,
 			       acl.posix_acl_hash);
 	if (rc) {
-		ksmbd_err("failed to generate hash for ndr acl\n");
+		pr_err("failed to generate hash for ndr acl\n");
 		goto out;
 	}
 
 	rc = ndr_encode_v4_ntacl(&sd_ndr, &acl);
 	if (rc) {
-		ksmbd_err("failed to encode ndr to posix acl\n");
+		pr_err("failed to encode ndr to posix acl\n");
 		goto out;
 	}
 
 	rc = ksmbd_vfs_setxattr(dentry, XATTR_NAME_SD, sd_ndr.data,
 				sd_ndr.offset, 0);
 	if (rc < 0)
-		ksmbd_err("Failed to store XATTR ntacl :%d\n", rc);
+		pr_err("Failed to store XATTR ntacl :%d\n", rc);
 
 	kfree(sd_ndr.data);
 out:
@@ -1570,19 +1570,19 @@ int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn, struct dentry *dentry,
 
 		rc = ndr_encode_posix_acl(&acl_ndr, inode, smb_acl, def_smb_acl);
 		if (rc) {
-			ksmbd_err("failed to encode ndr to posix acl\n");
+			pr_err("failed to encode ndr to posix acl\n");
 			goto out;
 		}
 
 		rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset,
 				       cmp_hash);
 		if (rc) {
-			ksmbd_err("failed to generate hash for ndr acl\n");
+			pr_err("failed to generate hash for ndr acl\n");
 			goto out;
 		}
 
 		if (memcmp(cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE)) {
-			ksmbd_err("hash value diff\n");
+			pr_err("hash value diff\n");
 			rc = -EINVAL;
 			goto out;
 		}
@@ -1821,11 +1821,11 @@ int ksmbd_vfs_copy_file_ranges(struct ksmbd_work *work,
 	*total_size_written = 0;
 
 	if (!(src_fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {
-		ksmbd_err("no right to read(%s)\n", FP_FILENAME(src_fp));
+		pr_err("no right to read(%s)\n", FP_FILENAME(src_fp));
 		return -EACCES;
 	}
 	if (!(dst_fp->daccess & (FILE_WRITE_DATA_LE | FILE_APPEND_DATA_LE))) {
-		ksmbd_err("no right to write(%s)\n", FP_FILENAME(dst_fp));
+		pr_err("no right to write(%s)\n", FP_FILENAME(dst_fp));
 		return -EACCES;
 	}
 
diff --git a/fs/cifsd/vfs_cache.c b/fs/cifsd/vfs_cache.c
index 4cf14c247e9e..c88210b15289 100644
--- a/fs/cifsd/vfs_cache.c
+++ b/fs/cifsd/vfs_cache.c
@@ -185,7 +185,7 @@ static struct ksmbd_inode *ksmbd_inode_get(struct ksmbd_file *fp)
 
 	rc = ksmbd_inode_init(ci, fp);
 	if (rc) {
-		ksmbd_err("inode initialized failed\n");
+		pr_err("inode initialized failed\n");
 		kfree(ci);
 		return NULL;
 	}
@@ -254,8 +254,8 @@ static void __ksmbd_inode_close(struct ksmbd_file *fp)
 		err = ksmbd_vfs_remove_xattr(filp->f_path.dentry,
 					     fp->stream.name);
 		if (err)
-			ksmbd_err("remove xattr failed : %s\n",
-				  fp->stream.name);
+			pr_err("remove xattr failed : %s\n",
+			       fp->stream.name);
 	}
 
 	if (atomic_dec_and_test(&ci->m_count)) {
@@ -542,7 +542,7 @@ struct ksmbd_file *ksmbd_open_fd(struct ksmbd_work *work, struct file *filp)
 
 	fp = kmem_cache_zalloc(filp_cache, GFP_KERNEL);
 	if (!fp) {
-		ksmbd_err("Failed to allocate memory\n");
+		pr_err("Failed to allocate memory\n");
 		return ERR_PTR(-ENOMEM);
 	}
 
@@ -698,7 +698,7 @@ int ksmbd_init_file_cache(void)
 	return 0;
 
 out:
-	ksmbd_err("failed to allocate file cache\n");
+	pr_err("failed to allocate file cache\n");
 	return -ENOMEM;
 }
 
-- 
2.33.0

