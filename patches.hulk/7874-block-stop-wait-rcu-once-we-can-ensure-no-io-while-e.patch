From 9c770585ff00466dfabc460e679144dca7e45ca0 Mon Sep 17 00:00:00 2001
From: yangerkun <yangerkun@huawei.com>
Date: Tue, 12 Oct 2021 16:37:48 +0800
Subject: [PATCH] block: stop wait rcu once we can ensure no io while elevator
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 9c770585ff00466dfabc460e679144dca7e45ca0

 init

Offering: HULK
hulk inclusion
category: performance
bugzilla: 174005 https://gitee.com/openeuler/kernel/issues/I4DDEL

---------------------------

'commit 737eb78e82d5 ("block: Delay default elevator initialization")'
delay elevator init to fix some problem for special device like SMR.
Also, the commit add the logic to ensure no IO can happened while
blk_mq_init_sched. However, blk_mq_freeze_queue/blk_mq_quiesce_queue
will add RCU Grace period which can lead some overhead(about 36 loop
device try to mount which each Grace period around 20ms).

For loop device, no io can happened while add_disk, so it's safe to skip
this step. Add flag QUEUE_FLAG_NO_INIT_IO to identify this case.

Signed-off-by: yangerkun <yangerkun@huawei.com>
Reviewed-by: Hou Tao <houtao1@huawei.com>
Signed-off-by: Chen Jun <chenjun102@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 block/elevator.c       | 14 ++++++++++----
 drivers/block/loop.c   |  5 +++++
 include/linux/blkdev.h |  2 ++
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/block/elevator.c b/block/elevator.c
index 293c5c81397a..dc756d4c2678 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -662,6 +662,7 @@ void elevator_init_mq(struct request_queue *q)
 {
 	struct elevator_type *e;
 	int err;
+	bool no_init_io;
 
 	if (!elv_support_iosched(q))
 		return;
@@ -678,13 +679,18 @@ void elevator_init_mq(struct request_queue *q)
 	if (!e)
 		return;
 
-	blk_mq_freeze_queue(q);
-	blk_mq_quiesce_queue(q);
+	no_init_io = blk_queue_no_init_io(q);
+	if (!no_init_io) {
+		blk_mq_freeze_queue(q);
+		blk_mq_quiesce_queue(q);
+	}
 
 	err = blk_mq_init_sched(q, e);
 
-	blk_mq_unquiesce_queue(q);
-	blk_mq_unfreeze_queue(q);
+	if (!no_init_io) {
+		blk_mq_unquiesce_queue(q);
+		blk_mq_unfreeze_queue(q);
+	}
 
 	if (err) {
 		pr_warn("\"%s\" elevator initialization failed, "
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index cd13c0eb3f63..31b1ef73b981 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -2175,6 +2175,11 @@ static int loop_add(struct loop_device **l, int i)
 	disk->private_data	= lo;
 	disk->queue		= lo->lo_queue;
 	sprintf(disk->disk_name, "loop%d", i);
+	/*
+	 * There won't be io before add_disk, QUEUE_FLAG_NO_INIT_IO can help
+	 * to save time while elevator_init_mq.
+	 */
+	blk_queue_flag_set(QUEUE_FLAG_NO_INIT_IO, lo->lo_queue);
 	add_disk(disk);
 	*l = lo;
 	return lo->lo_number;
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 542471b76f41..00e71019f4f6 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -621,6 +621,7 @@ struct request_queue {
 #define QUEUE_FLAG_RQ_ALLOC_TIME 27	/* record rq->alloc_time_ns */
 #define QUEUE_FLAG_HCTX_ACTIVE	28	/* at least one blk-mq hctx is active */
 #define QUEUE_FLAG_NOWAIT       29	/* device supports NOWAIT */
+#define QUEUE_FLAG_NO_INIT_IO	30	/* no IO can happen while elevator_init_mq */
 
 #define QUEUE_FLAG_MQ_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
 				 (1 << QUEUE_FLAG_SAME_COMP) |		\
@@ -667,6 +668,7 @@ bool blk_queue_flag_test_and_set(unsigned int flag, struct request_queue *q);
 #define blk_queue_fua(q)	test_bit(QUEUE_FLAG_FUA, &(q)->queue_flags)
 #define blk_queue_registered(q)	test_bit(QUEUE_FLAG_REGISTERED, &(q)->queue_flags)
 #define blk_queue_nowait(q)	test_bit(QUEUE_FLAG_NOWAIT, &(q)->queue_flags)
+#define blk_queue_no_init_io(q)	test_bit(QUEUE_FLAG_NO_INIT_IO, &(q)->queue_flags)
 
 extern void blk_set_pm_only(struct request_queue *q);
 extern void blk_clear_pm_only(struct request_queue *q);
-- 
2.26.2

