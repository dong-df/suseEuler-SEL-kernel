From 1ed78029eb460c778acd1ad91e53ce40cade0418 Mon Sep 17 00:00:00 2001
From: yangerkun <yangerkun@huawei.com>
Date: Mon, 15 Nov 2021 19:50:19 +0800
Subject: [PATCH] Revert "[Huawei] block: stop wait rcu once we can ensure no
Patch-mainline: Not yet, from openEuler
References: bsn#22
openEuler-commit: 1ed78029eb460c778acd1ad91e53ce40cade0418

 io while elevator init"

hulk inclusion
category: performance
bugzilla: 174005 https://gitee.com/openeuler/kernel/issues/I4DDEL

---------------------------

This reverts commit b2d85dfb8c1de87700afae78df99715d3a0788a5. This patch
is a local patch try to remove the useless rcu gap for loop setup. Now
mainline has the solution too. Revert local patch.

Signed-off-by: yangerkun <yangerkun@huawei.com>
Reviewed-by: Jason Yan <yanaijie@huawei.com>

Signed-off-by: Chen Jun <chenjun102@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Guoqing Jiang <guoqing.jiang@suse.com>
---
 block/elevator.c       | 14 ++++----------
 drivers/block/loop.c   |  5 -----
 include/linux/blkdev.h |  2 --
 3 files changed, 4 insertions(+), 17 deletions(-)

diff --git a/block/elevator.c b/block/elevator.c
index 0753255a8164..2a525863d4e9 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -665,7 +665,6 @@ void elevator_init_mq(struct request_queue *q)
 {
 	struct elevator_type *e;
 	int err;
-	bool no_init_io;
 
 	if (!elv_support_iosched(q))
 		return;
@@ -682,18 +681,13 @@ void elevator_init_mq(struct request_queue *q)
 	if (!e)
 		return;
 
-	no_init_io = blk_queue_no_init_io(q);
-	if (!no_init_io) {
-		blk_mq_freeze_queue(q);
-		blk_mq_quiesce_queue(q);
-	}
+	blk_mq_freeze_queue(q);
+	blk_mq_quiesce_queue(q);
 
 	err = blk_mq_init_sched(q, e);
 
-	if (!no_init_io) {
-		blk_mq_unquiesce_queue(q);
-		blk_mq_unfreeze_queue(q);
-	}
+	blk_mq_unquiesce_queue(q);
+	blk_mq_unfreeze_queue(q);
 
 	if (err) {
 		pr_warn("\"%s\" elevator initialization failed, "
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index 24f4192a2ffb..5dd8bd480e29 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -2176,11 +2176,6 @@ static int loop_add(struct loop_device **l, int i)
 	disk->private_data	= lo;
 	disk->queue		= lo->lo_queue;
 	sprintf(disk->disk_name, "loop%d", i);
-	/*
-	 * There won't be io before add_disk, QUEUE_FLAG_NO_INIT_IO can help
-	 * to save time while elevator_init_mq.
-	 */
-	blk_queue_flag_set(QUEUE_FLAG_NO_INIT_IO, lo->lo_queue);
 	add_disk(disk);
 	*l = lo;
 	return lo->lo_number;
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 8ea21d8eb1bf..7517381b5e15 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -622,7 +622,6 @@ struct request_queue {
 #define QUEUE_FLAG_RQ_ALLOC_TIME 27	/* record rq->alloc_time_ns */
 #define QUEUE_FLAG_HCTX_ACTIVE	28	/* at least one blk-mq hctx is active */
 #define QUEUE_FLAG_NOWAIT       29	/* device supports NOWAIT */
-#define QUEUE_FLAG_NO_INIT_IO	30	/* no IO can happen while elevator_init_mq */
 
 #define QUEUE_FLAG_MQ_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
 				 (1 << QUEUE_FLAG_SAME_COMP) |		\
@@ -669,7 +668,6 @@ bool blk_queue_flag_test_and_set(unsigned int flag, struct request_queue *q);
 #define blk_queue_fua(q)	test_bit(QUEUE_FLAG_FUA, &(q)->queue_flags)
 #define blk_queue_registered(q)	test_bit(QUEUE_FLAG_REGISTERED, &(q)->queue_flags)
 #define blk_queue_nowait(q)	test_bit(QUEUE_FLAG_NOWAIT, &(q)->queue_flags)
-#define blk_queue_no_init_io(q)	test_bit(QUEUE_FLAG_NO_INIT_IO, &(q)->queue_flags)
 
 extern void blk_set_pm_only(struct request_queue *q);
 extern void blk_clear_pm_only(struct request_queue *q);
-- 
2.26.2

